{"mappings":"IEOI,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,U,C,E,O,C,C,C,IC6CC,E,E,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,A,C,E,E,Q,A,E,Q,S,C,C,C,M,E,EFzCO,EAKA,E,E,E,O,C,sB,I,G,E,E,O,C,oB,I,G,E,E,O,C,Y,I,G,E,E,O,C,Q,I,GAZL,IAAM,EAAsB,CAAE,EAAG,CAAE,EAC7B,EAA4B,CACrC,IAAK,CAAA,EACL,MAAO,CAAA,EACP,OAAQ,CAAA,EACR,KAAM,CAAA,CACV,C,EACY,EAAA,GAAA,CAAA,EAAA,CAAA,CAAA,E,C,E,I,C,E,C,O,C,C,E,M,C,E,C,S,C,C,E,K,C,E,C,Q,CAKA,EAAA,GAAA,CAAA,EAAA,CAAA,CAAA,E,C,E,M,C,E,C,S,C,C,E,E,C,E,C,I,G,I,E,E,S,G,E,S,E,U,E,E,SEZZ,MAAM,EAAS,GAAI,AAAA,CAAA,EAAA,EAAA,EAAG,MAAM,CAAC,IAAK,KAKlC,IAAI,EAAQ,C,EA2CP,EAAA,GAAA,CAAA,EAAA,CAAA,CAAA,E,C,E,M,C,E,C,S,C,C,E,S,C,E,C,Y,C,C,E,I,C,E,C,O,C,C,E,M,C,E,C,QAofL,OAAM,EAWF,YAAY,CAAM,CAAE,CAA6B,CAAE,CAC/C,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,EAAO,EAAE,CACnB,IAAI,CAAC,KAAK,CAAG,EAAO,KAAK,CACzB,IAAI,CAAC,KAAK,CAAG,EAAO,KAAK,CACzB,IAAI,CAAC,SAAS,CAAG,EAAO,SAAS,CACjC,IAAI,CAAC,GAAG,CAAG,EAAG,YAAY,CAAC,EAAG,GAC9B,IAAI,CAAC,KAAK,CAAV,CACJ,CACA,OAAO,CAAiB,CAAE,CAAe,CAAE,CAAe,CAAQ,CAE9D,IAAM,EAAQ,IAAI,CAAC,KAAK,CAClB,EAAQ,IAAI,CAAC,KAAK,CAAC,KAAK,CACxB,EAAY,IAAI,CAAC,EAAE,CAAC,YAAY,CAClC,EAAU,AA3jBJ,IA2jBI,CAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CACrC,EAAU,AA5jBJ,IA4jBI,CAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,EAEnC,EAAW,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAGpE,GAAI,AAAU,IAAV,IAAI,CAAC,KAAK,EAAqB,AAAW,IAAX,EAAM,KAAK,EAAqB,CAAC,IAAI,CAAC,EAAE,CAAC,cAAc,CAGtF,OAFA,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAU,CAAC,CAAE,EAAU,CAAC,EAE9B,IAAI,CAIf,GACI,IAAI,CAAC,KAAK,GAAK,AAAA,EAAA,KAAI,CAAE,MAAM,EAC3B,IAAI,CAAC,EAAE,CAAC,cAAc,EACtB,AAAW,IAAX,EAAM,KAAK,EACX,AAAU,IAAV,IAAI,CAAC,KAAK,EAGN,AA9kBI,GA6kBS,EAAU,IAAI,GAAG,GAAG,CAAC,GAAU,GAAG,GAG/C,OADA,EAAM,KAAK,CAAG,IAAI,CAAC,KAAK,CAAxB,EACO,IAAI,CAUnB,GALI,IAAI,CAAC,KAAK,GAAK,AAAA,EAAA,KAAI,CAAE,MAAM,EAAI,AAAU,IAAV,IAAI,CAAC,KAAK,EAAmB,IAAI,CAAC,EAAE,CAAC,cAAc,EAClF,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAS,CAAC,CAAE,EAAS,CAAC,EAInC,IAAI,CAAC,KAAK,GAAK,AAAA,EAAA,KAAI,CAAE,MAAM,EAAI,AAAU,IAAV,IAAI,CAAC,KAAK,EAAmB,CAAC,IAAI,CAAC,EAAE,CAAC,cAAc,CAAE,CACrF,EAAM,KAAK,CAAG,IAAI,CAAC,KAAK,CAAxB,EAGA,IAAM,EAAS,EAAM,KAAK,CAAC,MAAM,CAEjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,IAAK,CAC7B,GAAI,IAAI,CAAC,SAAS,GAAK,GAAK,CAAK,CAAC,EAAE,CAAC,IAAI,CAAE,SAE3C,IAAM,EAAc,CAAK,CAAC,EAAE,CAO5B,GAAI,AA1mBA,GAymBa,AAJL,IAAI,CAAC,EAAE,CAAC,YAAY,CAC5B,EAAU,AAvmBZ,IAumBY,EAAY,GAAG,CAAC,CAAC,CAC3B,EAAU,AAxmBZ,IAwmBY,EAAY,GAAG,CAAC,CAAC,EAEV,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,GACjB,CACxB,GAAM,CAAA,QAAE,CAAO,CAAE,CAAG,IAAI,CAAC,YAAY,CAAC,EAAO,IAAI,CAAC,SAAS,CAAE,GAE7D,GAAI,CAAC,EAAS,SAGd,OADA,IAAI,CAAC,UAAU,CAAG,EACX,IAAI,AACf,CACJ,CAKA,OAFA,IAAI,CAAC,UAAU,CAAG,IAAI,CAAC,SAAS,CAEzB,IAAI,AACf,CAGA,GAAI,AAAU,IAAV,IAAI,CAAC,KAAK,CAAsB,CAChC,IAAM,EAAY,IAAI,CAAC,EAAE,CAAC,YAAY,CAClC,EAAU,AA9nBR,IA8nBQ,CAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CACtC,EAAU,AA/nBR,IA+nBQ,CAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,EAK1C,GAAI,AAnoBI,GAgoBS,EAAU,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,GAGvB,CAKxB,GAJA,EAAM,KAAK,CAAG,IAAI,CAAC,KAAK,CAAxB,EACA,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAU,CAAC,CAAE,EAAU,CAAC,EAGjC,IAAI,CAAC,UAAU,GAAK,IAAI,CAAC,SAAS,CAAE,CACpC,GAAM,CAAA,eAAE,CAAc,CAAA,QAAE,CAAO,CAAE,CAAG,IAAI,CAAC,YAAY,CAAC,EAAO,IAAI,CAAC,SAAS,CAAE,IAAI,CAAC,UAAU,EAE5F,GAAI,CAAC,EAAS,OAAO,IAAI,CAEzB,IAAM,EAAsB,CACxB,OAAQ,IAAI,CAAC,EAAE,CACf,gBAAiB,IAAI,CAAC,UAAU,CAChC,eAAA,EACA,UAAW,CACf,EAIA,GAHA,EAAM,QAAQ,CAAC,EAAO,GAGlB,EAAM,aAAa,GAAK,AAAA,EAAA,KAAI,CAAE,MAAM,CAAE,CACtC,IAAM,EAAS,EAAM,eAAe,CAAC,GACrC,GAAI,AAAW,KAAA,IAAX,EAGA,OAFA,EAAM,KAAK,CAAG,IAAI,CAAC,KAAK,CAAxB,EACA,EAAM,SAAS,EAAI,EAAM,SAAS,CAAC,GAC5B,IAAI,AAIf,CAAA,EAAM,aAAa,CAAG,AAAA,EAAA,KAAI,CAAE,EAAE,CAC9B,EAAM,QAAQ,EAClB,CACJ,CACA,OAAO,IAAI,AACf,CAGA,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAW,GAAG,CAAC,EAChC,CAEA,OAAO,IAAI,AACf,CAEA,MAAO,CAEH,GAAM,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,EAAE,CAElC,IAAI,CAAC,EAAE,CAAC,QAAQ,GAChB,IAAI,CAAC,KAAK,GAAK,AAAA,EAAA,KAAI,CAAE,EAAE,CAAG,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,GAAI,GAAI,IAAM,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAK,GAAI,IAC3E,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAClC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAtrBzB,IAyrBR,IAAI,CAAC,KAAK,GAAK,AAAA,EAAA,KAAI,CAAE,MAAM,EAAI,AAzrBvB,GAyrBuB,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,EAAQ,GAAQ,IAAI,CAAC,IAAI,CAAC,GAAG,GACjF,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAG3B,IAAI,CAAC,KAAK,CAAC,WAAW,GAEtB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,KACf,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,GACrB,IAAI,CAAC,EAAE,CAAC,MAAM,GACd,IAAI,CAAC,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAChD,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAE7E,CAEA,aACI,CAAkB,CAClB,CAAwB,CACxB,CAAuB,CACiC,CACxD,IACI,EADA,EAAU,CAAA,EAER,EAAO,EAAM,KAAK,CAAC,EAAiB,CAE1C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,iBAAiB,CAAC,MAAM,CAAE,IAAK,CACpD,IAAM,EAAY,EAAK,iBAAiB,CAAC,EAAE,CAE3C,GADI,CAAS,CAAC,EAAE,GAAK,GAAiB,CAAA,EAAU,CAAA,CAAhD,EAEI,CAAS,CAAC,EAAE,GAAK,GACjB,EAAM,KAAK,CAAC,CAAS,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,QAAU,IAAI,CAAC,KAAK,EACpD,EAAM,KAAK,CAAC,CAAS,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,QAAU,KAAA,EAC5C,CACE,IAAM,EAAe,EAAM,KAAK,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,SAAS,GAAK,CAAS,CAAC,EAAE,EACzE,EAAiB,GAAc,GAC/B,EAAU,CAAA,CACd,CACJ,CAEA,MAAO,CAAE,QAAA,EAAS,eAAA,CAAe,CACrC,CACJ,CAIA,SAAS,EAAW,CAAM,CAAE,CAAiB,EAgBzC,MAfsB,CAClB,IAAI,EAAK,EAAI,CAAE,GAAI,EAAG,MAAA,EAAO,MAAO,AAAA,EAAA,KAAI,CAAE,EAAE,CAAE,UAAW,CAAE,GAC3D,IAAI,EAAK,EAAI,CAAE,GAAI,EAAG,MAAA,EAAO,MAAO,AAAA,EAAA,KAAI,CAAE,EAAE,CAAE,UAAW,CAAE,GAC3D,IAAI,EAAK,EAAI,CAAE,GAAI,EAAG,MAAA,EAAO,MAAO,AAAA,EAAA,KAAI,CAAE,EAAE,CAAE,UAAW,CAAE,GAC3D,IAAI,EAAK,EAAI,CAAE,GAAI,EAAG,MAAA,EAAO,MAAO,AAAA,EAAA,KAAI,CAAE,EAAE,CAAE,UAAW,CAAE,GAC3D,IAAI,EAAK,EAAI,CAAE,GAAI,EAAG,MAAA,EAAO,MAAO,AAAA,EAAA,KAAI,CAAE,EAAE,CAAE,UAAW,CAAE,GAG3D,IAAI,EAAK,EAAI,CAAE,GAAI,EAAG,MAAA,EAAO,MAAO,AAAA,EAAA,KAAI,CAAE,MAAM,CAAE,UAAW,CAAE,GAC/D,IAAI,EAAK,EAAI,CAAE,GAAI,EAAG,MAAA,EAAO,MAAO,AAAA,EAAA,KAAI,CAAE,MAAM,CAAE,UAAW,CAAE,GAC/D,IAAI,EAAK,EAAI,CAAE,GAAI,EAAG,MAAA,EAAO,MAAO,AAAA,EAAA,KAAI,CAAE,MAAM,CAAE,UAAW,EAAG,GAChE,IAAI,EAAK,EAAI,CAAE,GAAI,EAAG,MAAA,EAAO,MAAO,AAAA,EAAA,KAAI,CAAE,MAAM,CAAE,UAAW,EAAG,GAChE,IAAI,EAAK,EAAI,CAAE,GAAI,EAAG,MAAA,EAAO,MAAO,AAAA,EAAA,KAAI,CAAE,MAAM,CAAE,UAAW,EAAG,GACnE,AAGL,CAEA,SAAS,EAAW,CAAM,CAAE,CAAa,EA8JrC,MA5JkC,CAC9B,CACI,GAAI,EACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,GAAG,CACV,CACD,KAAM,CAAK,CAAC,EAAE,AAClB,EACA,CACI,GAAI,EACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,GAAG,CACV,CACD,KAAM,CAAK,CAAC,EAAE,AAClB,EACA,CACI,GAAI,EACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,GAAG,CACV,CACD,KAAM,CAAK,CAAC,EAAE,AAClB,EAEA,CACI,GAAI,EACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,KAAA,EAAU,CACjB,CACD,KAAM,CAAK,CAAC,EAAE,AAClB,EACA,CACI,GAAI,EACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,EAAE,CACT,CACD,KAAM,CAAK,CAAC,EAAE,AAElB,EAEA,CACI,GAAI,EACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,GAAG,CACP,CAAC,GAAI,KAAA,EAAU,CAClB,CACD,KAAM,IACV,EACA,CACI,GAAI,EACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,GAAG,CACP,CAAC,GAAI,KAAA,EAAU,CACf,CAAC,EAAG,GAAG,CACP,CAAC,EAAG,KAAA,EAAU,CACjB,CACD,KAAM,IAEV,EACA,CACI,GAAI,EACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,GAAI,KAAA,EAAU,CACf,CAAC,EAAG,GAAG,CACP,CAAC,EAAG,EAAE,CACT,CACD,KAAM,IACV,EAEA,CACI,GAAI,EACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,EAAG,EAAE,CACN,CAAC,GAAI,KAAA,EAAU,CACf,CAAC,GAAI,KAAA,EAAU,CAClB,CACD,KAAM,CAAK,CAAC,EAAE,AAClB,EACA,CACI,GAAI,EACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,KAAA,EAAU,CACd,CAAC,GAAI,KAAA,EAAU,CACf,CAAC,GAAI,KAAA,EAAU,CAClB,CACD,KAAM,CAAK,CAAC,EAAE,AAClB,EAEA,CACI,GAAI,GACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,EAAE,CACN,CAAC,GAAI,GAAG,CACX,CACD,KAAM,CAAK,CAAC,EAAE,AAClB,EACA,CACI,GAAI,GACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,EAAE,CACN,CAAC,GAAI,KAAA,EAAU,CACf,CAAC,GAAI,KAAA,EAAU,CAClB,CACD,KAAM,CAAK,CAAC,EAAE,AAClB,EACA,CACI,GAAI,GACJ,IAAK,EAAG,YAAY,CAAC,EAAG,GACxB,kBAAmB,CACf,CAAC,EAAG,EAAE,CACN,CAAC,EAAG,EAAE,CACN,CAAC,GAAI,GAAG,CACX,CACD,KAAM,CAAK,CAAC,EAAE,AAClB,EACH,AAGL,CAEA,IAEA,EAl2BA,MAWI,YAAY,CAAM,CAAE,CAAoC,CAAE,CACtD,IAAM,EAA4B,CAAE,YAAa,CAAA,EAAO,cAAe,AAAA,EAAA,KAAI,CAAE,MAAM,CAAE,GAAG,CAAO,AAAC,CAChG,CAAA,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,aAAa,CAAG,EAAO,aAAa,CACzC,IAAI,CAAC,KAAK,CAAG,EAAW,EAAI,IAAI,EAChC,IAAI,CAAC,KAAK,CAAG,EAAW,EAAI,IAAI,CAAC,KAAK,EAEtC,IAAI,CAAC,KAAK,CAAV,EACA,IAAI,CAAC,WAAW,CAAG,EAAO,WAAW,CACrC,IAAI,CAAC,SAAS,CAAG,EAAO,SAAS,AACrC,CAEA,gBAAgB,CAAiB,CAAqB,CAClD,IAAI,EAAU,EACV,EAAc,EAGlB,OAFA,EAAM,KAAK,CAAC,OAAO,CAAC,AAAC,GAAO,EAAE,KAAK,GAAK,AAAA,EAAA,KAAI,CAAE,EAAE,CAAG,EAAE,EAAU,EAAE,GACpD,AAAY,IAAZ,EAAgB,AAAA,EAAA,KAAI,CAAE,MAAM,CAAG,AAAgB,IAAhB,EAAoB,AAAA,EAAA,KAAI,CAAE,EAAE,CAAG,KAAA,CAE/E,CAEA,WAAW,CAAiB,CAAE,CAAa,CAAsC,CAC7E,IAAI,EAAQ,EACR,EAAS,CAAA,EAEb,IAAK,IAAM,KAAQ,EAAM,KAAK,CAC1B,GAAS,EAAK,KAAK,GAAK,EAAS,GAAK,EAU1C,OAPK,EAAM,KAAK,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,KAAK,GAAK,AAAA,EAAA,KAAI,CAAE,EAAE,EAGrC,EAAM,KAAK,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,KAAK,GAAK,AAAA,EAAA,KAAI,CAAE,MAAM,IACxD,GAAS,KACT,EAAS,CAAA,IAJT,GAAS,IACT,EAAS,CAAA,GAKN,CAAE,MAAA,EAAO,OAAA,CAAO,CAC3B,CAEA,UAAW,CACP,EAAQ,EAER,IAAM,EAAgB,IAAI,CAAC,aAAa,CAClC,EAAa,IAAkB,AAAA,EAAA,KAAI,CAAE,EAAE,CAAG,AAAA,EAAA,KAAI,CAAE,MAAM,CAAG,AAAA,EAAA,KAAI,CAAE,EAAE,CACnE,EAAY,CAAC,IACb,EAAsB,KACtB,EAAQ,CAAC,IACT,EAAO,IAIX,IAAK,IAAM,KAHX,IAAI,CAAC,EAAE,CAAC,MAAM,GAGK,AAVL,IAAI,CAUO,KAAK,EAC1B,GAAI,EAAK,KAAK,GAAK,EAInB,IAAK,IAAM,KAAa,AAHJ,AAZV,IAAI,CAYY,KAAK,CAAC,EAAK,SAAS,CAAC,CAGX,iBAAiB,CAAE,CACnD,IAAM,EAAqB,CAAS,CAAC,EAAE,CACjC,EAAsB,CAAS,CAAC,EAAE,CAClC,EAAgB,AAlBhB,IAAI,CAkBkB,KAAK,CAAC,EAAmB,CAAC,IAAI,CAG1D,GACI,AAAwB,KAAA,IAAxB,GACA,CAAC,AAvBC,IAAI,CAuBC,KAAK,CAAC,EAAoB,CAAC,IAAI,EACtC,GACA,EAAc,KAAK,GAAK,EAC1B,CAEE,IAAM,EAAiB,EAAK,SAAS,AACrC,CAAA,EAAK,SAAS,CAAG,EACjB,AA9BE,IAAI,CA8BA,KAAK,CAAC,EAAoB,CAAC,IAAI,CAAG,EACxC,AA/BE,IAAI,CA+BA,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,KAGnC,IAAM,EAAQ,AAlCZ,IAAI,CAkCc,KAAK,CAAC,SAAS,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,AAD/B,EAC4C,EAAE,EAC/D,EAAQ,KACR,AApCF,IAAI,CAoCI,KAAK,CAAC,EAAmB,CAAC,IAAI,CAAG,KACvC,AArCF,IAAI,CAqCI,KAAK,CAAC,MAAM,CAAC,EAAO,IAI9B,IAAM,EAAQ,IAAI,CAAC,OAAO,CAzCxB,IAAI,CAxGR,EAoJM,CAAA,EACA,EACA,EACA,EACA,CAAC,WAAW,EAAE,EAAK,EAAE,CAAC,EAAE,EAAE,EAAe,CAAC,EAAE,EAAoB,CAAC,EAGrE,AAnDE,IAAI,CAmDA,KAAK,CAAC,MAAM,CAAC,EAAO,EAlBL,GAmBrB,AApDE,IAAI,CAoDA,KAAK,CAAC,AAnBS,EAmBI,SAAS,CAAC,CAAC,IAAI,CAnBnB,EAoBrB,EAAK,SAAS,CAAG,EACjB,AAtDE,IAAI,CAsDA,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,EACnC,AAvDE,IAAI,CAuDA,KAAK,CAAC,EAAmB,CAAC,IAAI,CAtBf,EAuBrB,AAxDE,IAAI,CAwDA,KAAK,CAAC,EAAoB,CAAC,IAAI,CAAG,KAEpC,EAAQ,IACR,EAAY,EACZ,EAAW,CACP,OAAQ,EAAK,EAAE,CACf,gBAAiB,EACjB,eAAgB,AA9BH,EA8BgB,EAAE,CAC/B,UAAA,CACJ,EAER,MAGK,GAAI,CAAC,EAAe,CAErB,IAAM,EAAiB,EAAK,SAAS,AACrC,CAAA,EAAK,SAAS,CAAG,EACjB,AA1EE,IAAI,CA0EA,KAAK,CAAC,EAAmB,CAAC,IAAI,CAAG,EACvC,AA3EE,IAAI,CA2EA,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,KAGnC,IAAM,EAAQ,IAAI,CAAC,OAAO,CA9ExB,IAAI,CAxGR,EAyLM,CAAA,EACA,EACA,EACA,EACA,CAAC,WAAW,EAAE,EAAK,EAAE,CAAC,EAAE,EAAE,EAAe,CAAC,EAAE,EAAmB,CAAC,CAGpE,CAAA,EAAK,SAAS,CAAG,EACjB,AAzFE,IAAI,CAyFA,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,EACnC,AA1FE,IAAI,CA0FA,KAAK,CAAC,EAAmB,CAAC,IAAI,CAAG,KAEnC,EAAQ,IACR,EAAY,EACZ,EAAW,CAAE,OAAQ,EAAK,EAAE,CAAE,gBAAiB,EAAoB,UAAA,CAAU,EAErF,CACJ,CAGJ,GAAI,EAAU,CACV,IAAI,CAAC,QAAQ,CArGH,IAAI,CAqGO,GAGrB,IAAM,EAAS,AAxGL,IAAI,CAwGO,eAAe,CAxG1B,IAAI,EA0Gd,GAAI,AAAW,KAAA,IAAX,EAAsB,CACtB,AA3GM,IAAI,CA2GJ,KAAK,CAAG,IAAI,CAAC,KAAK,CAAxB,EACA,AA5GM,IAAI,CA4GJ,SAAS,EAAI,AA5Gb,IAAI,CA4Ge,SAAS,CAAC,GACnC,MACJ,CAGA,AAjHU,IAAI,CAiHR,aAAa,CAAG,EACtB,IAAI,CAAC,EAAE,CAAC,IAAI,EAChB,CACJ,CAEA,QACI,CAAiB,CACjB,CAAa,CACb,CAAqB,CACrB,CAAiB,CACjB,CAAa,CACb,CAAY,CACZ,CAAc,CACR,CACN,EAAE,EACF,GAAM,CAAA,MAAE,CAAK,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,UAAU,CAAC,EAAO,GAE3C,EAAgB,IAAe,AAAA,EAAA,KAAI,CAAE,EAAE,CAAG,AAAA,EAAA,KAAI,CAAE,MAAM,CAAG,AAAA,EAAA,KAAI,CAAE,EAAE,CAGvE,GAAI,GAAS,GAAK,EAAQ,OAAO,EAAS,CAAA,EAAQ,CAAA,EAElD,GAAI,EAAc,CACd,IAAI,EAAY,CAAC,IAEjB,IAAK,IAAM,KAAQ,EAAM,KAAK,CAC1B,GAAI,EAAK,KAAK,GAAK,EAInB,IAAK,IAAM,KAAa,AAHJ,EAAM,KAAK,CAAC,EAAK,SAAS,CAAC,CAGX,iBAAiB,CAAE,CACnD,IAAM,EAAqB,CAAS,CAAC,EAAE,CACjC,EAAsB,CAAS,CAAC,EAAE,CAClC,EAAgB,EAAM,KAAK,CAAC,EAAmB,CAAC,IAAI,CAG1D,GACI,AAAwB,KAAA,IAAxB,GACA,CAAC,EAAM,KAAK,CAAC,EAAoB,CAAC,IAAI,EACtC,GACA,EAAc,KAAK,GAAK,EAC1B,CAEE,IAAM,EAAiB,EAAK,SAAS,AACrC,CAAA,EAAK,SAAS,CAAG,EACjB,EAAM,KAAK,CAAC,EAAoB,CAAC,IAAI,CAAG,EACxC,EAAM,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,KAGnC,IAAM,EAAQ,EAAM,KAAK,CAAC,SAAS,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,AAD/B,EAC4C,EAAE,EAC/D,EAAQ,KACR,EAAM,KAAK,CAAC,EAAmB,CAAC,IAAI,CAAG,KACvC,EAAM,KAAK,CAAC,MAAM,CAAC,EAAO,IAI9B,IAAM,EAAQ,IAAI,CAAC,OAAO,CACtB,EACA,EAAQ,EACR,CAAA,EACA,EACA,EACA,EACA,CAAC,WAAW,EAAE,EAAK,EAAE,CAAC,EAAE,EAAE,EAAe,CAAC,EAAE,EAAoB,CAAC,EAarE,GAXA,EAAY,KAAK,GAAG,CAAC,EAAO,GAG5B,EAAM,KAAK,CAAC,MAAM,CAAC,EAAO,EApBL,GAqBrB,EAAM,KAAK,CAAC,AArBS,EAqBI,SAAS,CAAC,CAAC,IAAI,CArBnB,EAsBrB,EAAK,SAAS,CAAG,EACjB,EAAM,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,EACnC,EAAM,KAAK,CAAC,EAAmB,CAAC,IAAI,CAxBf,EAyBrB,EAAM,KAAK,CAAC,EAAoB,CAAC,IAAI,CAAG,KAKhC,GADJ,CAAA,EAAQ,KAAK,GAAG,CAAC,EAAO,EAAxB,EACmB,KAE3B,MAGK,GAAI,CAAC,EAAe,CAErB,IAAM,EAAiB,EAAK,SAAS,AACrC,CAAA,EAAK,SAAS,CAAG,EACjB,EAAM,KAAK,CAAC,EAAmB,CAAC,IAAI,CAAG,EACvC,EAAM,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,KAGnC,IAAM,EAAQ,IAAI,CAAC,OAAO,CACtB,EACA,EAAQ,EACR,CAAA,EACA,EACA,EACA,EACA,CAAC,WAAW,EAAE,EAAK,EAAE,CAAC,EAAE,EAAE,EAAe,CAAC,EAAE,EAAmB,CAAC,EAUpE,GARA,EAAY,KAAK,GAAG,CAAC,EAAO,GAG5B,EAAK,SAAS,CAAG,EACjB,EAAM,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,EACnC,EAAM,KAAK,CAAC,EAAmB,CAAC,IAAI,CAAG,KAK/B,GADJ,CAAA,EAAQ,KAAK,GAAG,CAAC,EAAO,EAAxB,EACmB,KAE3B,CACJ,CAGJ,OAAO,CACX,CAAO,CACH,IAAI,EAAY,IAEhB,IAAK,IAAM,KAAQ,EAAM,KAAK,CAC1B,GAAI,EAAK,KAAK,GAAK,EAInB,IAAK,IAAM,KAAa,AAHJ,EAAM,KAAK,CAAC,EAAK,SAAS,CAAC,CAGX,iBAAiB,CAAE,CACnD,IAAM,EAAqB,CAAS,CAAC,EAAE,CACjC,EAAsB,CAAS,CAAC,EAAE,CAClC,EAAgB,EAAM,KAAK,CAAC,EAAmB,CAAC,IAAI,CAG1D,GACI,AAAwB,KAAA,IAAxB,GACA,CAAC,EAAM,KAAK,CAAC,EAAoB,CAAC,IAAI,EACtC,GACA,EAAc,KAAK,GAAK,EAC1B,CAEE,IAAM,EAAiB,EAAK,SAAS,AACrC,CAAA,EAAK,SAAS,CAAG,EACjB,EAAM,KAAK,CAAC,EAAoB,CAAC,IAAI,CAAG,EACxC,EAAM,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,KAGnC,IAAM,EAAQ,EAAM,KAAK,CAAC,SAAS,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,AAD/B,EAC4C,EAAE,EAC/D,EAAQ,KACR,EAAM,KAAK,CAAC,EAAmB,CAAC,IAAI,CAAG,KACvC,EAAM,KAAK,CAAC,MAAM,CAAC,EAAO,IAI9B,IAAM,EAAQ,IAAI,CAAC,OAAO,CACtB,EACA,EAAQ,EACR,CAAA,EACA,EACA,EACA,EACA,CAAC,WAAW,EAAE,EAAK,EAAE,CAAC,EAAE,EAAE,EAAe,CAAC,EAAE,EAAoB,CAAC,EAarE,GAXA,EAAY,KAAK,GAAG,CAAC,EAAO,GAG5B,EAAM,KAAK,CAAC,MAAM,CAAC,EAAO,EApBL,GAqBrB,EAAM,KAAK,CAAC,AArBS,EAqBI,SAAS,CAAC,CAAC,IAAI,CArBnB,EAsBrB,EAAK,SAAS,CAAG,EACjB,EAAM,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,EACnC,EAAM,KAAK,CAAC,EAAmB,CAAC,IAAI,CAxBf,EAyBrB,EAAM,KAAK,CAAC,EAAoB,CAAC,IAAI,CAAG,KAKhC,AADJ,CAAA,EAAO,KAAK,GAAG,CAAC,EAAM,EAAtB,GACY,EAAO,KAE3B,MAGK,GAAI,CAAC,EAAe,CAErB,IAAM,EAAiB,EAAK,SAAS,AACrC,CAAA,EAAK,SAAS,CAAG,EACjB,EAAM,KAAK,CAAC,EAAmB,CAAC,IAAI,CAAG,EACvC,EAAM,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,KAGnC,IAAM,EAAQ,IAAI,CAAC,OAAO,CACtB,EACA,EAAQ,EACR,CAAA,EACA,EACA,EACA,EACA,CAAC,WAAW,EAAE,EAAK,EAAE,CAAC,EAAE,EAAE,EAAe,CAAC,EAAE,EAAmB,CAAC,EAUpE,GARA,EAAY,KAAK,GAAG,CAAC,EAAO,GAG5B,EAAK,SAAS,CAAG,EACjB,EAAM,KAAK,CAAC,EAAe,CAAC,IAAI,CAAG,EACnC,EAAM,KAAK,CAAC,EAAmB,CAAC,IAAI,CAAG,KAK/B,AADJ,CAAA,EAAO,KAAK,GAAG,CAAC,EAAM,EAAtB,GACY,EAAO,KAE3B,CACJ,CAGJ,OAAO,CACX,CACJ,CAEA,SAAS,CAAiB,CAAE,CAAmB,CAAc,CACzD,GAAI,CAAC,EAAU,OAAO,EACtB,GAAM,CAAA,OAAE,CAAM,CAAA,gBAAE,CAAe,CAAA,eAAE,CAAc,CAAE,CAAG,EAC9C,EAAO,EAAM,KAAK,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,GAC9C,GAAI,AAAS,KAAA,IAAT,EAAoB,CACpB,IAAM,EAAW,EAAK,SAAS,CAK/B,GAJA,EAAK,SAAS,CAAG,EACjB,EAAM,KAAK,CAAC,EAAgB,CAAC,IAAI,CAAG,EACpC,EAAM,KAAK,CAAC,EAAS,CAAC,IAAI,CAAG,KAEzB,AAAmB,KAAA,IAAnB,EAA8B,CAC9B,IAAM,EAAe,EAAM,KAAK,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,GACtD,GAAI,CAAC,EAAc,OAAO,EAC1B,IAAM,EAAQ,EAAM,KAAK,CAAC,SAAS,CAAC,AAAC,GAAM,EAAE,EAAE,GAAK,GAAc,IAC9D,EAAQ,KACR,EAAM,KAAK,CAAC,EAAa,SAAS,CAAC,CAAC,IAAI,CAAG,KAC3C,EAAM,KAAK,CAAC,MAAM,CAAC,EAAO,GAElC,CACJ,CACA,OAAO,CACX,CACA,OAAO,CAAiB,CAAQ,CAG5B,IAAK,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,IAAK,CACxC,IAAM,EAAO,IAAI,CAAC,KAAK,CAAC,EAAE,AACb,CAAA,IAAI,CAAC,KAAK,CAAC,EAAK,SAAS,CAAC,CAEvC,EAAK,MAAM,CAAC,EAAW,EAAO,CAAC,CAAE,EAAO,CAAC,CAC7C,CACA,OAAO,IAAI,AACf,CAEA,MAAO,CAEH,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAE5B,IAAK,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,IAAK,CACxC,GAAM,CAAE,EAAG,CAAE,CAAE,EAAG,CAAE,CAAE,CAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CACpC,EAAO,EAAO,CAAC,CAAG,AA1dlB,IA0dkB,EAClB,EAAO,EAAO,CAAC,CAAG,AA3dlB,IA2dkB,EAClB,EAAiB,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,EAAM,GAyBlD,GAtBA,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,iBAAiB,CAAC,OAAO,CAAC,AAAC,IACrC,IAAM,EAAQ,CAAS,CAAC,EAAE,CACpB,CAAE,EAAG,CAAE,CAAE,EAAG,CAAE,CAAE,CAAG,IAAI,CAAC,KAAK,CAAC,EAAM,CAAC,GAAG,CAC9C,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,GACrB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAK,IACpB,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,EAAM,EAAM,EAAO,CAAC,CAAG,AApelC,IAoekC,EAAgB,EAAO,CAAC,CAAG,AApe7D,IAoe6D,EACnE,GAGI,IAAI,CAAC,WAAW,GAEhB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,KACf,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,GACrB,IAAI,CAAC,EAAE,CAAC,MAAM,GACd,IAAI,CAAC,EAAE,CAAC,IAAI,CACR,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,AAAuB,OAAvB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAY,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,EAAE,GAAK,GAAG,CAAC,CACnF,EAAO,GACP,EAAO,IAKX,AAAC,CAAA,AAAU,IAAV,IAAI,CAAC,KAAK,EAAqB,AAAU,IAAV,IAAI,CAAC,KAAK,AAAA,GAAoB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,EAAE,QAAU,AAAA,EAAA,KAAI,CAAE,EAAE,CAAE,CACtG,IAAM,EAAW,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,CAAC,GAAgB,GAAG,GACzF,EAxfA,KAyfA,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAC3B,IAAI,CAAC,EAAE,CAAC,QAAQ,GAChB,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,KACb,IAAI,CAAC,EAAE,CAAC,MAAM,CACV,EAAe,CAAC,CAChB,EAAe,CAAC,CAChB,IAAI,CAAC,EAAE,CAAC,SAAS,CAAC,AA/ftB,GA+foC,EAAU,EAAG,KAGzD,CACJ,CAGA,IAAK,IAAM,KAAQ,IAAI,CAAC,KAAK,CACzB,EAAK,IAAI,EAEjB,CAEA,UAAU,CAAS,CAAE,CAAc,CAAE,CACjC,GACS,gBADD,EAEA,IAAI,CAAC,WAAW,CAAG,OAGnB,KAAM,uCAElB,CAEA,UAAU,CAAoC,CAAE,CAC5C,IAAM,EAA4B,CAAE,YAAa,CAAA,EAAO,cAAe,AAAA,EAAA,KAAI,CAAE,MAAM,CAAE,GAAG,CAAO,AAAC,CAChG,CAAA,IAAI,CAAC,aAAa,CAAG,EAAO,aAAa,CACzC,IAAI,CAAC,KAAK,CAAG,EAAW,IAAI,CAAC,EAAE,CAAE,IAAI,EACrC,IAAI,CAAC,KAAK,CAAG,EAAW,IAAI,CAAC,EAAE,CAAE,IAAI,CAAC,KAAK,EAE3C,IAAI,CAAC,KAAK,CAAV,EACA,IAAI,CAAC,WAAW,CAAG,EAAO,WAAW,CACrC,IAAI,CAAC,SAAS,CAAG,EAAO,SAAS,AACrC,CACJ,E,E,E,SD5hBA,MAAM,EAAiB,SAAS,cAAc,CAAC,cACzC,EAAkB,SAAS,cAAc,CAAC,UAkFhD,GAAI,CAAA,EAAA,EAAA,EA9EW,AAAC,IACZ,IAAM,EAAU,CACZ,KAAM,IACN,YAAa,CAAA,CACjB,EAEM,EAAM,IAAI,EAAA,GAAE,CAAE,CAAE,UAAW,CAAA,CAAM,GA6DvC,SAAS,EAAU,CAAa,EAC5B,IAAM,EAAO,IAAW,AAAA,EAAA,KAAI,CAAE,MAAM,CAAG,YAAc,cACrD,QAAQ,GAAG,CAAC,GACR,GAAgB,CAAA,EAAe,KAAK,CAAC,OAAO,CAAG,MAAnD,EACI,GAAiB,CAAA,EAAgB,SAAS,CAAG,CAAjD,CACJ,CAjEA,EAAI,UAAU,CAAC,EAAE,CAAG,MACpB,SAAS,cAAc,CAAC,QAAQ,YAAY,EAAI,UAAU,EAC1D,EAAI,GAAG,CAAC,EAAS,eAAe,QAAQ,CAAC,AAAC,IACtC,EAAM,SAAS,CAAC,cAAe,EACnC,GACA,EAAI,GAAG,CAAC,EAAS,OAAQ,IAAK,IAAK,IAAI,QAAQ,CAAC,AAAC,IAEjD,GAGA,EAAG,KAAK,CAAG,KAEP,AADe,EAAG,YAAY,CAAC,OAAO,UAAU,CAAE,OAAO,WAAW,EAC7D,MAAM,CAAC,OACd,EAAG,UAAU,CAAC,SACd,EAAG,YAAY,CAAC,GAChB,EAAG,SAAS,CAAC,EAAG,GAAG,EACnB,OAAO,gBAAgB,CAAC,SAAU,IAAM,AAgC5C,CAAA,SAAuB,CAAU,EAC7B,EAAO,YAAY,CAAC,OAAO,UAAU,CAAE,OAAO,WAAW,CAC7D,CAAA,EAlC0D,IAGlD,GAAgB,CAAA,EAAe,KAAK,CAAC,GAAG,CAAG,CAAC,EAAG,AAAA,CAAA,OAAO,WAAW,CAAG,EAAQ,IAAG,AAAH,EAAQ,EAAI,GAAG,EAAE,CAAC,AAAD,EACjG,GAAgB,iBAAiB,SAAU,AAAC,IACxC,EAAM,cAAc,GACpB,EAAe,KAAK,CAAC,OAAO,CAAG,OAC/B,EAAM,SAAS,CAAC,CAAE,cAAe,AAAA,EAAA,KAAI,CAAE,MAAM,CAAE,YAAa,EAAQ,WAAW,CAAE,UAAA,CAAU,GAC3F,EAAG,IAAI,EACX,GA4BA,AA1BK,EA0BF,UAAU,CAAC,IAAK,GAAI,IAIvB,AADA,CAAA,EAAQ,IAAI,EA7BP,EA6BsB,CAAE,cAAe,AAAA,EAAA,KAAI,CAAE,MAAM,CAAE,YAAa,EAAQ,WAAW,CAAE,UAAA,CAAU,EAAA,EAChG,aAAa,GAAK,AAAA,EAAA,KAAI,CAAE,MAAM,CAAG,AA9BlC,EA8BqC,IAAI,GAAK,AA9B9C,EA8BiD,MAAM,EA7BhE,EAGA,EAAG,IAAI,CAAG,KACN,EAAG,UAAU,CAAC,IAAK,GAAI,IACvB,GAAO,OAAO,EAAG,SAAS,EAAE,MAChC,EAEA,EAAG,YAAY,CAAG,AAAC,IACf,GAAI,EAAE,MAAM,GAAK,AAAA,EAAA,SAAQ,CAAE,IAAI,CAAE,MAMrC,CA0BJ","sources":["<anon>","src/utils/utils.ts","src/scripts/board-game.ts","src/libs/cross-board.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequirebf15\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequirebf15\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"fK5g3\", function(module, exports) {\n\n$parcel$export(module.exports, \"defaultEntityConfig\", () => $28770b279d7ab5b1$export$73820bb3da69f923);\n$parcel$export(module.exports, \"defaultEdgeConfig\", () => $28770b279d7ab5b1$export$1ea8cd15d9ca5dee);\n$parcel$export(module.exports, \"MOUSE_BTN\", () => $28770b279d7ab5b1$export$bfd2dc5313efa3a3);\n$parcel$export(module.exports, \"Gamer\", () => $28770b279d7ab5b1$export$4008efb11b076cd5);\nconst $28770b279d7ab5b1$export$73820bb3da69f923 = {\n    r: 5\n};\nconst $28770b279d7ab5b1$export$1ea8cd15d9ca5dee = {\n    top: true,\n    right: true,\n    bottom: true,\n    left: true\n};\nvar $28770b279d7ab5b1$export$bfd2dc5313efa3a3;\n(function(MOUSE_BTN) {\n    MOUSE_BTN[MOUSE_BTN[\"LEFT\"] = 0] = \"LEFT\";\n    MOUSE_BTN[MOUSE_BTN[\"MIDDLE\"] = 1] = \"MIDDLE\";\n    MOUSE_BTN[MOUSE_BTN[\"RIGHT\"] = 2] = \"RIGHT\";\n})($28770b279d7ab5b1$export$bfd2dc5313efa3a3 || ($28770b279d7ab5b1$export$bfd2dc5313efa3a3 = {}));\nvar $28770b279d7ab5b1$export$4008efb11b076cd5;\n(function(Gamer) {\n    Gamer[Gamer[\"PLAYER\"] = 0] = \"PLAYER\";\n    Gamer[Gamer[\"AI\"] = 1] = \"AI\";\n})($28770b279d7ab5b1$export$4008efb11b076cd5 || ($28770b279d7ab5b1$export$4008efb11b076cd5 = {}));\n\n});\n\n\nvar $e93rA = parcelRequire(\"e93rA\");\n\nvar $7Pz0b = parcelRequire(\"7Pz0b\");\n\nvar $7Pz0b = parcelRequire(\"7Pz0b\");\n\nvar $fK5g3 = parcelRequire(\"fK5g3\");\n// --------------------------------------------------------\nconst $dc260c8a25c170be$var$OFFSET = new (0, (/*@__PURE__*/$parcel$interopDefault($7Pz0b))).Vector(150, 150);\nconst $dc260c8a25c170be$var$PAWN_RADIUS = 30;\nconst $dc260c8a25c170be$var$DIMENSION = 100;\nconst $dc260c8a25c170be$var$SNAP_RADIUS = 30;\nconst $dc260c8a25c170be$var$MAX_DEPTH = 5;\nlet $dc260c8a25c170be$var$count = 0;\nconst $dc260c8a25c170be$var$ENABLE_PRUNING = true;\nvar $dc260c8a25c170be$var$STATE;\n(function(STATE) {\n    STATE[STATE[\"NORMAL\"] = 0] = \"NORMAL\";\n    STATE[STATE[\"ANIMATION\"] = 1] = \"ANIMATION\";\n    STATE[STATE[\"DRAG\"] = 2] = \"DRAG\";\n    STATE[STATE[\"PAUSED\"] = 3] = \"PAUSED\";\n})($dc260c8a25c170be$var$STATE || ($dc260c8a25c170be$var$STATE = {}));\n// --------------------------------------------------------\n// --------------------------------------------------------\nclass $dc260c8a25c170be$var$CrossBoard {\n    constructor(p5, _config){\n        const config = {\n            showHelpers: false,\n            currentPlayer: (0, $fK5g3.Gamer).PLAYER,\n            ..._config\n        };\n        this.p5 = p5;\n        this.currentPlayer = config.currentPlayer;\n        this.pawns = $dc260c8a25c170be$var$buildPawns(p5, this);\n        this.cells = $dc260c8a25c170be$var$buildBoard(p5, this.pawns);\n        this.state = 0;\n        this.showHelpers = config.showHelpers;\n        this.onResolve = config.onResolve;\n    }\n    checkGameStatus(board) {\n        let aiPawns = 0;\n        let playerPawns = 0;\n        board.pawns.forEach((p)=>p.owner === (0, $fK5g3.Gamer).AI ? ++aiPawns : ++playerPawns);\n        let winner = aiPawns === 0 ? (0, $fK5g3.Gamer).PLAYER : playerPawns === 0 ? (0, $fK5g3.Gamer).AI : undefined;\n        return winner;\n    }\n    checkScore(board, player) {\n        let score = 0;\n        let hasWon = false;\n        // const hasWon = !board.pawns.some((p) => p.owner === Gamer.AI) || !board.pawns.some((p) => p.owner === Gamer.PLAYER);\n        for (const pawn of board.pawns)score += pawn.owner === player ? -1 : 1;\n        // multiply with a large number to influence the weight\n        if (!board.pawns.some((p)=>p.owner === (0, $fK5g3.Gamer).AI)) {\n            score *= 1000;\n            hasWon = true;\n        } else if (!board.pawns.some((p)=>p.owner === (0, $fK5g3.Gamer).PLAYER)) {\n            score *= -1000;\n            hasWon = true;\n        }\n        return {\n            score: score,\n            hasWon: hasWon\n        };\n    }\n    nextMove() {\n        $dc260c8a25c170be$var$count = 0;\n        const board = this;\n        const currentPlayer = this.currentPlayer;\n        const nextPlayer = currentPlayer === (0, $fK5g3.Gamer).AI ? (0, $fK5g3.Gamer).PLAYER : (0, $fK5g3.Gamer).AI;\n        let bestScore = -Infinity;\n        let bestMove = null;\n        let alpha = -Infinity;\n        let beta = Infinity;\n        this.p5.noLoop();\n        // search through the available pawns\n        for (const pawn of board.pawns){\n            if (pawn.owner !== currentPlayer) continue;\n            const currentCell = board.cells[pawn.cellIndex];\n            // find neighbour cell\n            for (const connector of currentCell.connectingIndices){\n                const neighbourCellIndex = connector[0];\n                const capturableCellIndex = connector[1];\n                const neighbourPawn = board.cells[neighbourCellIndex].pawn;\n                // check for capturable cells\n                if (capturableCellIndex !== undefined && !board.cells[capturableCellIndex].pawn && neighbourPawn && neighbourPawn.owner !== currentPlayer) {\n                    // pre-calc\n                    const stashCellIndex = pawn.cellIndex;\n                    pawn.cellIndex = capturableCellIndex;\n                    board.cells[capturableCellIndex].pawn = pawn;\n                    board.cells[stashCellIndex].pawn = null;\n                    // delete captured pawn\n                    const capturedPawn = neighbourPawn;\n                    const index = board.pawns.findIndex((p)=>p.id === capturedPawn.id);\n                    if (index > -1) {\n                        board.cells[neighbourCellIndex].pawn = null;\n                        board.pawns.splice(index, 1);\n                    }\n                    // depth\n                    const score = this.minimax(board, $dc260c8a25c170be$var$MAX_DEPTH, false, currentPlayer, alpha, beta, `cap// pawn(${pawn.id}) ${stashCellIndex}-${capturableCellIndex}`);\n                    // undo minimax changes\n                    board.pawns.splice(index, 0, capturedPawn);\n                    board.cells[capturedPawn.cellIndex].pawn = capturedPawn;\n                    pawn.cellIndex = stashCellIndex;\n                    board.cells[stashCellIndex].pawn = pawn;\n                    board.cells[neighbourCellIndex].pawn = capturedPawn;\n                    board.cells[capturableCellIndex].pawn = null;\n                    if (score > bestScore) {\n                        bestScore = score;\n                        bestMove = {\n                            pawnId: pawn.id,\n                            targetCellIndex: capturableCellIndex,\n                            capturedPawnId: capturedPawn.id,\n                            bestScore: bestScore\n                        };\n                    }\n                } else if (!neighbourPawn) {\n                    // pre-calc\n                    const stashCellIndex = pawn.cellIndex;\n                    pawn.cellIndex = neighbourCellIndex;\n                    board.cells[neighbourCellIndex].pawn = pawn;\n                    board.cells[stashCellIndex].pawn = null;\n                    // depth\n                    const score = this.minimax(board, $dc260c8a25c170be$var$MAX_DEPTH, false, currentPlayer, alpha, beta, `mov// pawn(${pawn.id}) ${stashCellIndex}-${neighbourCellIndex}`);\n                    // undo minimax changes\n                    pawn.cellIndex = stashCellIndex;\n                    board.cells[stashCellIndex].pawn = pawn;\n                    board.cells[neighbourCellIndex].pawn = null;\n                    if (score > bestScore) {\n                        bestScore = score;\n                        bestMove = {\n                            pawnId: pawn.id,\n                            targetCellIndex: neighbourCellIndex,\n                            bestScore: bestScore\n                        };\n                    }\n                }\n            }\n        }\n        // initiate board move\n        if (bestMove) {\n            this.movePawn(board, bestMove);\n            // check for a winner\n            const winner = board.checkGameStatus(board);\n            if (winner !== undefined) {\n                board.state = this.state = 3;\n                board.onResolve && board.onResolve(winner);\n                return;\n            }\n            // toggle player if noo winner\n            board.currentPlayer = nextPlayer;\n            this.p5.loop();\n        }\n    }\n    minimax(board, depth, isMaximizing, lastPlayer, alpha, beta, status) {\n        ++$dc260c8a25c170be$var$count;\n        const { score: score, hasWon: hasWon } = this.checkScore(board, lastPlayer);\n        const currentPlayer = lastPlayer === (0, $fK5g3.Gamer).AI ? (0, $fK5g3.Gamer).PLAYER : (0, $fK5g3.Gamer).AI;\n        // if (depth <= 0 || count > 100) return score;\n        // if (depth <= 0) return score;\n        if (depth <= 0 || hasWon) return score * (depth + 1);\n        if (isMaximizing) {\n            let bestScore = -Infinity;\n            // calc start\n            for (const pawn of board.pawns){\n                if (pawn.owner !== currentPlayer) continue;\n                const currentCell = board.cells[pawn.cellIndex];\n                // find neighbour cell\n                for (const connector of currentCell.connectingIndices){\n                    const neighbourCellIndex = connector[0];\n                    const capturableCellIndex = connector[1];\n                    const neighbourPawn = board.cells[neighbourCellIndex].pawn;\n                    // check for capturable cells\n                    if (capturableCellIndex !== undefined && !board.cells[capturableCellIndex].pawn && neighbourPawn && neighbourPawn.owner !== currentPlayer) {\n                        // pre-calc\n                        const stashCellIndex = pawn.cellIndex;\n                        pawn.cellIndex = capturableCellIndex;\n                        board.cells[capturableCellIndex].pawn = pawn;\n                        board.cells[stashCellIndex].pawn = null;\n                        // delete captured pawn\n                        const capturedPawn = neighbourPawn;\n                        const index = board.pawns.findIndex((p)=>p.id === capturedPawn.id);\n                        if (index > -1) {\n                            board.cells[neighbourCellIndex].pawn = null;\n                            board.pawns.splice(index, 1);\n                        }\n                        // depth\n                        const score = this.minimax(board, depth - 1, false, currentPlayer, alpha, beta, `cap++ pawn(${pawn.id}) ${stashCellIndex}-${capturableCellIndex}`);\n                        bestScore = Math.max(score, bestScore);\n                        // undo minimax changes\n                        board.pawns.splice(index, 0, capturedPawn);\n                        board.cells[capturedPawn.cellIndex].pawn = capturedPawn;\n                        pawn.cellIndex = stashCellIndex;\n                        board.cells[stashCellIndex].pawn = pawn;\n                        board.cells[neighbourCellIndex].pawn = capturedPawn;\n                        board.cells[capturableCellIndex].pawn = null;\n                        // alpha-beta\n                        if ($dc260c8a25c170be$var$ENABLE_PRUNING) {\n                            alpha = Math.max(alpha, score);\n                            if (beta <= alpha) break;\n                        }\n                    } else if (!neighbourPawn) {\n                        // pre-calc\n                        const stashCellIndex = pawn.cellIndex;\n                        pawn.cellIndex = neighbourCellIndex;\n                        board.cells[neighbourCellIndex].pawn = pawn;\n                        board.cells[stashCellIndex].pawn = null;\n                        // depth\n                        const score = this.minimax(board, depth - 1, false, currentPlayer, alpha, beta, `mov++ pawn(${pawn.id}) ${stashCellIndex}-${neighbourCellIndex}`);\n                        bestScore = Math.max(score, bestScore);\n                        // undo minimax changes\n                        pawn.cellIndex = stashCellIndex;\n                        board.cells[stashCellIndex].pawn = pawn;\n                        board.cells[neighbourCellIndex].pawn = null;\n                        // alpha-beta\n                        if ($dc260c8a25c170be$var$ENABLE_PRUNING) {\n                            alpha = Math.max(alpha, score);\n                            if (beta <= alpha) break;\n                        }\n                    }\n                }\n            }\n            // calc end\n            return bestScore;\n        } else {\n            let bestScore = Infinity;\n            // calc start\n            for (const pawn of board.pawns){\n                if (pawn.owner !== currentPlayer) continue;\n                const currentCell = board.cells[pawn.cellIndex];\n                // find neighbour cell\n                for (const connector of currentCell.connectingIndices){\n                    const neighbourCellIndex = connector[0];\n                    const capturableCellIndex = connector[1];\n                    const neighbourPawn = board.cells[neighbourCellIndex].pawn;\n                    // check for capturable cells\n                    if (capturableCellIndex !== undefined && !board.cells[capturableCellIndex].pawn && neighbourPawn && neighbourPawn.owner !== currentPlayer) {\n                        // pre-calc\n                        const stashCellIndex = pawn.cellIndex;\n                        pawn.cellIndex = capturableCellIndex;\n                        board.cells[capturableCellIndex].pawn = pawn;\n                        board.cells[stashCellIndex].pawn = null;\n                        // delete captured pawn\n                        const capturedPawn = neighbourPawn;\n                        const index = board.pawns.findIndex((p)=>p.id === capturedPawn.id);\n                        if (index > -1) {\n                            board.cells[neighbourCellIndex].pawn = null;\n                            board.pawns.splice(index, 1);\n                        }\n                        // depth\n                        const score = this.minimax(board, depth - 1, true, currentPlayer, alpha, beta, `cap-- pawn(${pawn.id}) ${stashCellIndex}-${capturableCellIndex}`);\n                        bestScore = Math.min(score, bestScore);\n                        // undo minimax changes\n                        board.pawns.splice(index, 0, capturedPawn);\n                        board.cells[capturedPawn.cellIndex].pawn = capturedPawn;\n                        pawn.cellIndex = stashCellIndex;\n                        board.cells[stashCellIndex].pawn = pawn;\n                        board.cells[neighbourCellIndex].pawn = capturedPawn;\n                        board.cells[capturableCellIndex].pawn = null;\n                        // alpha-beta\n                        if ($dc260c8a25c170be$var$ENABLE_PRUNING) {\n                            beta = Math.min(beta, score);\n                            if (beta <= alpha) break;\n                        }\n                    } else if (!neighbourPawn) {\n                        // pre-calc\n                        const stashCellIndex = pawn.cellIndex;\n                        pawn.cellIndex = neighbourCellIndex;\n                        board.cells[neighbourCellIndex].pawn = pawn;\n                        board.cells[stashCellIndex].pawn = null;\n                        // depth\n                        const score = this.minimax(board, depth - 1, true, currentPlayer, alpha, beta, `mov-- pawn(${pawn.id}) ${stashCellIndex}-${neighbourCellIndex}`);\n                        bestScore = Math.min(score, bestScore);\n                        // undo minimax changes\n                        pawn.cellIndex = stashCellIndex;\n                        board.cells[stashCellIndex].pawn = pawn;\n                        board.cells[neighbourCellIndex].pawn = null;\n                        // alpha-beta\n                        if ($dc260c8a25c170be$var$ENABLE_PRUNING) {\n                            beta = Math.min(beta, score);\n                            if (beta <= alpha) break;\n                        }\n                    }\n                }\n            }\n            // calc end\n            return bestScore;\n        }\n    }\n    movePawn(board, bestMove) {\n        if (!bestMove) return board;\n        const { pawnId: pawnId, targetCellIndex: targetCellIndex, capturedPawnId: capturedPawnId } = bestMove;\n        const pawn = board.pawns.find((p)=>p.id === pawnId);\n        if (pawn !== undefined) {\n            const tempCell = pawn.cellIndex;\n            pawn.cellIndex = targetCellIndex;\n            board.cells[targetCellIndex].pawn = pawn;\n            board.cells[tempCell].pawn = null;\n            if (capturedPawnId !== undefined) {\n                const capturedPawn = board.pawns.find((p)=>p.id === capturedPawnId);\n                if (!capturedPawn) return board;\n                const index = board.pawns.findIndex((p)=>p.id === capturedPawn?.id);\n                if (index > -1) {\n                    board.cells[capturedPawn.cellIndex].pawn = null;\n                    board.pawns.splice(index, 1);\n                }\n            }\n        }\n        return board;\n    }\n    update(deltaTime) {\n        // board:update()\n        // update pawns\n        for(let i = 0; i < this.pawns.length; i++){\n            const pawn = this.pawns[i];\n            const cell = this.cells[pawn.cellIndex];\n            // pawn.update(this.p5.deltaTime, OFFSET.x + cell.pos.x * DIMENSION, OFFSET.y + cell.pos.y * DIMENSION);\n            pawn.update(deltaTime, $dc260c8a25c170be$var$OFFSET.x, $dc260c8a25c170be$var$OFFSET.y);\n        }\n        return this;\n    }\n    draw() {\n        // bord:draw()\n        this.p5.cursor(this.p5.ARROW);\n        for(let i = 0; i < this.cells.length; i++){\n            const { x: x1, y: y1 } = this.cells[i].pos;\n            const posX = $dc260c8a25c170be$var$OFFSET.x + x1 * $dc260c8a25c170be$var$DIMENSION;\n            const posY = $dc260c8a25c170be$var$OFFSET.y + y1 * $dc260c8a25c170be$var$DIMENSION;\n            const currentCellPos = this.p5.createVector(posX, posY);\n            // draw lines to neighbours\n            this.cells[i].connectingIndices.forEach((neighbour)=>{\n                const index = neighbour[0];\n                const { x: x2, y: y2 } = this.cells[index].pos;\n                this.p5.strokeWeight(2);\n                this.p5.stroke(255, 0.1);\n                this.p5.line(posX, posY, $dc260c8a25c170be$var$OFFSET.x + x2 * $dc260c8a25c170be$var$DIMENSION, $dc260c8a25c170be$var$OFFSET.y + y2 * $dc260c8a25c170be$var$DIMENSION);\n            });\n            // draw helpers\n            if (this.showHelpers) {\n                // points texts\n                this.p5.stroke(255);\n                this.p5.strokeWeight(1);\n                this.p5.noFill();\n                this.p5.text(`${this.cells[i].id}  ${this.cells[i].pawn !== null ? this.cells[i].pawn?.id : \"\"}`, posX + 25, posY - 5);\n            }\n            // draw hover point\n            if ((this.state === 0 || this.state === 2) && this.cells[i].pawn?.owner !== (0, $fK5g3.Gamer).AI) {\n                const distance = this.p5.createVector(this.p5.mouseX, this.p5.mouseY).sub(currentCellPos).mag();\n                if (distance < $dc260c8a25c170be$var$PAWN_RADIUS) {\n                    this.p5.cursor(this.p5.HAND);\n                    this.p5.noStroke();\n                    this.p5.fill(255);\n                    this.p5.circle(currentCellPos.x, currentCellPos.y, this.p5.constrain($dc260c8a25c170be$var$PAWN_RADIUS - distance, 0, $dc260c8a25c170be$var$PAWN_RADIUS * 0.5));\n                }\n            }\n        }\n        // draw cells\n        for (const pawn of this.pawns)pawn.draw();\n    }\n    setValues(key, value) {\n        switch(key){\n            case \"showHelpers\":\n                this.showHelpers = value;\n                break;\n            default:\n                throw \"Unsupported key passed to setValues()\";\n        }\n    }\n    resetGame(_config) {\n        const config = {\n            showHelpers: false,\n            currentPlayer: (0, $fK5g3.Gamer).PLAYER,\n            ..._config\n        };\n        this.currentPlayer = config.currentPlayer;\n        this.pawns = $dc260c8a25c170be$var$buildPawns(this.p5, this);\n        this.cells = $dc260c8a25c170be$var$buildBoard(this.p5, this.pawns);\n        this.state = 0;\n        this.showHelpers = config.showHelpers;\n        this.onResolve = config.onResolve;\n    }\n}\n// --------------------------------------------------------\n// --------------------------------------------------------\nclass $dc260c8a25c170be$var$Pawn {\n    constructor(p5, config){\n        this.p5 = p5;\n        this.id = config.id;\n        this.board = config.board;\n        this.owner = config.owner;\n        this.cellIndex = config.cellIndex;\n        this.pos = p5.createVector(0, 0);\n        this.state = 0;\n    }\n    update(deltaTime, offsetX, offsetY) {\n        // pawn:update()\n        const board = this.board;\n        const cells = this.board.cells;\n        const parentPos = this.p5.createVector(offsetX + cells[this.cellIndex].pos.x * $dc260c8a25c170be$var$DIMENSION, offsetY + cells[this.cellIndex].pos.y * $dc260c8a25c170be$var$DIMENSION);\n        const mousePos = this.p5.createVector(this.p5.mouseX, this.p5.mouseY);\n        // update Cells at rest\n        if (this.state === 0 && board.state === 0 && !this.p5.mouseIsPressed) {\n            this.pos.set(parentPos.x, parentPos.y);\n            return this;\n        }\n        // initiate dragging\n        if (this.owner === (0, $fK5g3.Gamer).PLAYER && this.p5.mouseIsPressed && board.state === 0 && this.state === 0) {\n            const distance = parentPos.copy().sub(mousePos).mag();\n            if (distance < $dc260c8a25c170be$var$SNAP_RADIUS) {\n                board.state = this.state = 2;\n                return this;\n            }\n        }\n        // continue dragging\n        if (this.owner === (0, $fK5g3.Gamer).PLAYER && this.state === 2 && this.p5.mouseIsPressed) this.pos.set(mousePos.x, mousePos.y);\n        // finish drag state when mouseup\n        if (this.owner === (0, $fK5g3.Gamer).PLAYER && this.state === 2 && !this.p5.mouseIsPressed) {\n            board.state = this.state = 1;\n            // calculate the permissible cells\n            const length = board.cells.length;\n            for(let i = 0; i < length; i++){\n                if (this.cellIndex === i || cells[i].pawn) continue;\n                const currentCell = cells[i];\n                const pos = this.p5.createVector(offsetX + currentCell.pos.x * $dc260c8a25c170be$var$DIMENSION, offsetY + currentCell.pos.y * $dc260c8a25c170be$var$DIMENSION);\n                const distance = pos.copy().sub(this.pos).mag();\n                if (distance < $dc260c8a25c170be$var$SNAP_RADIUS) {\n                    const { isLegal: isLegal } = this.getLegalMove(board, this.cellIndex, i);\n                    if (!isLegal) continue;\n                    // set the new target cell to move\n                    this.targetCell = i;\n                    return this;\n                }\n            }\n            // no snappable points, return to home\n            this.targetCell = this.cellIndex;\n            return this;\n        }\n        // travel to position\n        if (this.state === 1) {\n            const targetPos = this.p5.createVector(offsetX + cells[this.targetCell].pos.x * $dc260c8a25c170be$var$DIMENSION, offsetY + cells[this.targetCell].pos.y * $dc260c8a25c170be$var$DIMENSION);\n            const distance = targetPos.copy().sub(this.pos).mag();\n            // if near a cell, snap to it\n            if (distance < $dc260c8a25c170be$var$SNAP_RADIUS) {\n                board.state = this.state = 0;\n                this.pos.set(targetPos.x, targetPos.y);\n                // commit to the move\n                if (this.targetCell !== this.cellIndex) {\n                    const { capturedPawnId: capturedPawnId, isLegal: isLegal } = this.getLegalMove(board, this.cellIndex, this.targetCell);\n                    if (!isLegal) return this;\n                    const bestMove = {\n                        pawnId: this.id,\n                        targetCellIndex: this.targetCell,\n                        capturedPawnId: capturedPawnId,\n                        bestScore: 0\n                    };\n                    board.movePawn(board, bestMove);\n                    // check for a winner\n                    if (board.currentPlayer === (0, $fK5g3.Gamer).PLAYER) {\n                        const winner = board.checkGameStatus(board);\n                        if (winner !== undefined) {\n                            board.state = this.state = 3;\n                            board.onResolve && board.onResolve(winner);\n                            return this;\n                        }\n                        // if there is no winner\n                        board.currentPlayer = (0, $fK5g3.Gamer).AI;\n                        board.nextMove();\n                    }\n                }\n                return this;\n            }\n            // if not near any cells, move to target\n            this.pos.add(targetPos).div(2);\n        }\n        return this;\n    }\n    draw() {\n        // pawn:draw()\n        const { mouseX: mouseX, mouseY: mouseY } = this.p5;\n        // pawn style\n        this.p5.noStroke();\n        this.owner === (0, $fK5g3.Gamer).AI ? this.p5.fill(10, 80, 70) : this.p5.fill(200, 80, 70);\n        this.p5.ellipseMode(this.p5.CENTER);\n        this.p5.circle(this.pos.x, this.pos.y, $dc260c8a25c170be$var$PAWN_RADIUS);\n        // draw curson\n        if (this.owner === (0, $fK5g3.Gamer).PLAYER && this.p5.createVector(mouseX, mouseY).dist(this.pos) < $dc260c8a25c170be$var$PAWN_RADIUS) this.p5.cursor(this.p5.HAND);\n        if (this.board.showHelpers) {\n            // points texts\n            this.p5.stroke(255);\n            this.p5.strokeWeight(1);\n            this.p5.noFill();\n            this.p5.textAlign(this.p5.CENTER, this.p5.CENTER);\n            this.p5.text(`${this.id} (${this.cellIndex})`, this.pos.x, this.pos.y);\n        }\n    }\n    getLegalMove(board, currentCellIndex, targetCellIndex) {\n        let isLegal = false;\n        let capturedPawnId;\n        const cell = board.cells[currentCellIndex];\n        for(let i = 0; i < cell.connectingIndices.length; i++){\n            const connector = cell.connectingIndices[i];\n            if (connector[0] === targetCellIndex) isLegal = true;\n            if (connector[1] === targetCellIndex && board.cells[connector[0]].pawn?.owner !== this.owner && board.cells[connector[0]].pawn?.owner !== undefined) {\n                const capturedPawn = board.pawns.find((p)=>p.cellIndex === connector[0]);\n                capturedPawnId = capturedPawn?.id;\n                isLegal = true;\n            }\n        }\n        return {\n            isLegal: isLegal,\n            capturedPawnId: capturedPawnId\n        };\n    }\n}\n// --------------------------------------------------------\n// --------------------------------------------------------\nfunction $dc260c8a25c170be$var$buildPawns(p5, board) {\n    const pawns = [\n        new $dc260c8a25c170be$var$Pawn(p5, {\n            id: 0,\n            board: board,\n            owner: (0, $fK5g3.Gamer).AI,\n            cellIndex: 0\n        }),\n        new $dc260c8a25c170be$var$Pawn(p5, {\n            id: 1,\n            board: board,\n            owner: (0, $fK5g3.Gamer).AI,\n            cellIndex: 1\n        }),\n        new $dc260c8a25c170be$var$Pawn(p5, {\n            id: 2,\n            board: board,\n            owner: (0, $fK5g3.Gamer).AI,\n            cellIndex: 2\n        }),\n        new $dc260c8a25c170be$var$Pawn(p5, {\n            id: 3,\n            board: board,\n            owner: (0, $fK5g3.Gamer).AI,\n            cellIndex: 3\n        }),\n        new $dc260c8a25c170be$var$Pawn(p5, {\n            id: 4,\n            board: board,\n            owner: (0, $fK5g3.Gamer).AI,\n            cellIndex: 4\n        }),\n        // new Pawn(p5, { id: 4, board, owner: Gamer.AI, cellIndex: 6 }),\n        new $dc260c8a25c170be$var$Pawn(p5, {\n            id: 5,\n            board: board,\n            owner: (0, $fK5g3.Gamer).PLAYER,\n            cellIndex: 8\n        }),\n        new $dc260c8a25c170be$var$Pawn(p5, {\n            id: 6,\n            board: board,\n            owner: (0, $fK5g3.Gamer).PLAYER,\n            cellIndex: 9\n        }),\n        new $dc260c8a25c170be$var$Pawn(p5, {\n            id: 7,\n            board: board,\n            owner: (0, $fK5g3.Gamer).PLAYER,\n            cellIndex: 10\n        }),\n        new $dc260c8a25c170be$var$Pawn(p5, {\n            id: 8,\n            board: board,\n            owner: (0, $fK5g3.Gamer).PLAYER,\n            cellIndex: 11\n        }),\n        new $dc260c8a25c170be$var$Pawn(p5, {\n            id: 9,\n            board: board,\n            owner: (0, $fK5g3.Gamer).PLAYER,\n            cellIndex: 12\n        })\n    ];\n    return pawns;\n}\nfunction $dc260c8a25c170be$var$buildBoard(p5, pawns) {\n    // build points\n    const points = [\n        {\n            id: 0,\n            pos: p5.createVector(0, 0),\n            connectingIndices: [\n                [\n                    1,\n                    2\n                ],\n                [\n                    3,\n                    6\n                ],\n                [\n                    5,\n                    10\n                ]\n            ],\n            pawn: pawns[0]\n        },\n        {\n            id: 1,\n            pos: p5.createVector(2, 0),\n            connectingIndices: [\n                [\n                    0,\n                    undefined\n                ],\n                [\n                    2,\n                    undefined\n                ],\n                [\n                    3,\n                    5\n                ],\n                [\n                    4,\n                    7\n                ],\n                [\n                    6,\n                    11\n                ]\n            ],\n            pawn: pawns[1]\n        },\n        {\n            id: 2,\n            pos: p5.createVector(4, 0),\n            connectingIndices: [\n                [\n                    1,\n                    0\n                ],\n                [\n                    4,\n                    6\n                ],\n                [\n                    7,\n                    12\n                ]\n            ],\n            pawn: pawns[2]\n        },\n        {\n            id: 3,\n            pos: p5.createVector(1, 1),\n            connectingIndices: [\n                [\n                    0,\n                    undefined\n                ],\n                [\n                    1,\n                    undefined\n                ],\n                [\n                    6,\n                    9\n                ],\n                [\n                    5,\n                    undefined\n                ]\n            ],\n            pawn: pawns[3]\n        },\n        {\n            id: 4,\n            pos: p5.createVector(3, 1),\n            connectingIndices: [\n                [\n                    1,\n                    undefined\n                ],\n                [\n                    2,\n                    undefined\n                ],\n                [\n                    7,\n                    undefined\n                ],\n                [\n                    6,\n                    8\n                ]\n            ],\n            pawn: pawns[4]\n        },\n        {\n            id: 5,\n            pos: p5.createVector(0, 2),\n            connectingIndices: [\n                [\n                    0,\n                    undefined\n                ],\n                [\n                    3,\n                    1\n                ],\n                [\n                    6,\n                    7\n                ],\n                [\n                    8,\n                    11\n                ],\n                [\n                    10,\n                    undefined\n                ]\n            ],\n            pawn: null\n        },\n        {\n            id: 6,\n            pos: p5.createVector(2, 2),\n            connectingIndices: [\n                [\n                    3,\n                    0\n                ],\n                [\n                    1,\n                    undefined\n                ],\n                [\n                    4,\n                    2\n                ],\n                [\n                    7,\n                    undefined\n                ],\n                [\n                    9,\n                    12\n                ],\n                [\n                    11,\n                    undefined\n                ],\n                [\n                    8,\n                    10\n                ],\n                [\n                    5,\n                    undefined\n                ]\n            ],\n            pawn: null\n        },\n        {\n            id: 7,\n            pos: p5.createVector(4, 2),\n            connectingIndices: [\n                [\n                    4,\n                    1\n                ],\n                [\n                    2,\n                    undefined\n                ],\n                [\n                    12,\n                    undefined\n                ],\n                [\n                    9,\n                    11\n                ],\n                [\n                    6,\n                    5\n                ]\n            ],\n            pawn: null\n        },\n        {\n            id: 8,\n            pos: p5.createVector(1, 3),\n            connectingIndices: [\n                [\n                    5,\n                    undefined\n                ],\n                [\n                    6,\n                    4\n                ],\n                [\n                    11,\n                    undefined\n                ],\n                [\n                    10,\n                    undefined\n                ]\n            ],\n            pawn: pawns[5]\n        },\n        {\n            id: 9,\n            pos: p5.createVector(3, 3),\n            connectingIndices: [\n                [\n                    6,\n                    3\n                ],\n                [\n                    7,\n                    undefined\n                ],\n                [\n                    12,\n                    undefined\n                ],\n                [\n                    11,\n                    undefined\n                ]\n            ],\n            pawn: pawns[6]\n        },\n        {\n            id: 10,\n            pos: p5.createVector(0, 4),\n            connectingIndices: [\n                [\n                    5,\n                    0\n                ],\n                [\n                    8,\n                    6\n                ],\n                [\n                    11,\n                    12\n                ]\n            ],\n            pawn: pawns[7]\n        },\n        {\n            id: 11,\n            pos: p5.createVector(2, 4),\n            connectingIndices: [\n                [\n                    8,\n                    5\n                ],\n                [\n                    6,\n                    1\n                ],\n                [\n                    9,\n                    7\n                ],\n                [\n                    12,\n                    undefined\n                ],\n                [\n                    10,\n                    undefined\n                ]\n            ],\n            pawn: pawns[8]\n        },\n        {\n            id: 12,\n            pos: p5.createVector(4, 4),\n            connectingIndices: [\n                [\n                    9,\n                    6\n                ],\n                [\n                    7,\n                    2\n                ],\n                [\n                    11,\n                    10\n                ]\n            ],\n            pawn: pawns[9]\n        }\n    ];\n    return points;\n}\nvar // --------------------------------------------------------\n// --------------------------------------------------------\n$dc260c8a25c170be$export$2e2bcd8739ae039 = $dc260c8a25c170be$var$CrossBoard;\n\n\n\nvar $fK5g3 = parcelRequire(\"fK5g3\");\n/**--------------------------------- */ // variables & types\nlet $0af410a66d517047$var$board;\nconst $0af410a66d517047$var$scoreContainer = document.getElementById(\"score-card\");\nconst $0af410a66d517047$var$statusContainer = document.getElementById(\"status\");\n/**--------------------------------- */ // sketch\nconst $0af410a66d517047$var$sketch = (p5)=>{\n    const options = {\n        size: 400,\n        showHelpers: true\n    };\n    const gui = new (0, $e93rA.GUI)({\n        autoPlace: false\n    });\n    gui.domElement.id = \"gui\";\n    document.getElementById(\"gui\")?.appendChild(gui.domElement);\n    gui.add(options, \"showHelpers\").onChange((val)=>{\n        $0af410a66d517047$var$board.setValues(\"showHelpers\", val);\n    });\n    gui.add(options, \"size\", 200, 500, 10).onChange((val)=>{\n    // board.setValues('size', val);\n    });\n    /** setup */ p5.setup = ()=>{\n        const canvas = p5.createCanvas(window.innerWidth, window.innerHeight);\n        canvas.parent(\"app\");\n        p5.background(\"white\");\n        p5.pixelDensity(1);\n        p5.colorMode(p5.HSB);\n        window.addEventListener(\"resize\", ()=>resizeDisplay(p5));\n        // setup markup\n        if ($0af410a66d517047$var$scoreContainer) $0af410a66d517047$var$scoreContainer.style.top = `${(window.innerHeight + options.size) / 2 + 30}px`;\n        $0af410a66d517047$var$scoreContainer?.addEventListener(\"submit\", (event)=>{\n            event.preventDefault();\n            $0af410a66d517047$var$scoreContainer.style.display = \"none\";\n            $0af410a66d517047$var$board.resetGame({\n                currentPlayer: (0, $fK5g3.Gamer).PLAYER,\n                showHelpers: options.showHelpers,\n                onResolve: onResolve\n            });\n            p5.loop();\n        });\n        init(p5);\n    };\n    /** draw */ p5.draw = ()=>{\n        p5.background(200, 60, 10);\n        $0af410a66d517047$var$board?.update(p5.deltaTime).draw();\n    };\n    p5.mouseClicked = (e)=>{\n        if (e.button !== (0, $fK5g3.MOUSE_BTN).LEFT) return;\n    // console.log(board);\n    // p5.background(200, 60, 10);\n    // board.nextMove(board);\n    // board.update(1).draw();\n    };\n    /**--------------------------------- */ // functions\n    function resizeDisplay(canvas) {\n        canvas.resizeCanvas(window.innerWidth, window.innerHeight);\n    }\n    function init(p5) {\n        p5.background(200, 60, 10);\n        //setup board\n        $0af410a66d517047$var$board = new (0, $dc260c8a25c170be$export$2e2bcd8739ae039)(p5, {\n            currentPlayer: (0, $fK5g3.Gamer).PLAYER,\n            showHelpers: options.showHelpers,\n            onResolve: onResolve\n        });\n        $0af410a66d517047$var$board.currentPlayer === (0, $fK5g3.Gamer).PLAYER ? p5.loop() : p5.noLoop();\n    }\n    function onResolve(winner) {\n        const text = winner === (0, $fK5g3.Gamer).PLAYER ? \"You Win!!\" : \"You Loose!!\";\n        console.log(text);\n        if ($0af410a66d517047$var$scoreContainer) $0af410a66d517047$var$scoreContainer.style.display = \"flex\";\n        if ($0af410a66d517047$var$statusContainer) $0af410a66d517047$var$statusContainer.innerText = text;\n    }\n/**--------------------------------- */ // classes\n};\nnew (0, (/*@__PURE__*/$parcel$interopDefault($7Pz0b)))($0af410a66d517047$var$sketch);\n\n\n//# sourceMappingURL=board-game.07ec6702.js.map\n","import P5 from 'p5';\r\nimport { TEdges } from './types';\r\nimport CrossBoard from 'src/libs/cross-board-2';\r\n\r\nexport const defaultEntityConfig = { r: 5 };\r\nexport const defaultEdgeConfig: TEdges = {\r\n    top: true,\r\n    right: true,\r\n    bottom: true,\r\n    left: true\r\n};\r\nexport enum MOUSE_BTN {\r\n    LEFT,\r\n    MIDDLE,\r\n    RIGHT\r\n}\r\nexport enum Gamer {\r\n    PLAYER,\r\n    AI\r\n}\r\nexport type TTicTacToeCell = {\r\n    pos: P5.Vector;\r\n    owner: Gamer | undefined;\r\n};\r\nexport type TGameStatus = {\r\n    filledCells: number;\r\n    winner: Gamer | undefined;\r\n    cells: TTicTacToeCell[];\r\n};\r\n","import { GUI } from 'dat.gui';\r\nimport P5 from 'p5';\r\nimport CrossBoard from 'src/libs/cross-board';\r\nimport { Gamer, MOUSE_BTN } from 'src/utils/utils';\r\n\r\n/**--------------------------------- */\r\n// variables & types\r\nlet board: CrossBoard;\r\nconst scoreContainer = document.getElementById('score-card');\r\nconst statusContainer = document.getElementById('status');\r\n\r\n/**--------------------------------- */\r\n// sketch\r\nconst sketch = (p5: P5) => {\r\n    const options = {\r\n        size: 400,\r\n        showHelpers: true\r\n    };\r\n\r\n    const gui = new GUI({ autoPlace: false });\r\n    gui.domElement.id = 'gui';\r\n    document.getElementById('gui')?.appendChild(gui.domElement);\r\n    gui.add(options, 'showHelpers').onChange((val) => {\r\n        board.setValues('showHelpers', val);\r\n    });\r\n    gui.add(options, 'size', 200, 500, 10).onChange((val) => {\r\n        // board.setValues('size', val);\r\n    });\r\n\r\n    /** setup */\r\n    p5.setup = () => {\r\n        const canvas = p5.createCanvas(window.innerWidth, window.innerHeight);\r\n        canvas.parent('app');\r\n        p5.background('white');\r\n        p5.pixelDensity(1);\r\n        p5.colorMode(p5.HSB);\r\n        window.addEventListener('resize', () => resizeDisplay(p5));\r\n\r\n        // setup markup\r\n        if (scoreContainer) scoreContainer.style.top = `${(window.innerHeight + options.size) / 2 + 30}px`;\r\n        scoreContainer?.addEventListener('submit', (event: FormDataEvent) => {\r\n            event.preventDefault();\r\n            scoreContainer.style.display = 'none';\r\n            board.resetGame({ currentPlayer: Gamer.PLAYER, showHelpers: options.showHelpers, onResolve });\r\n            p5.loop();\r\n        });\r\n\r\n        init(p5);\r\n    };\r\n\r\n    /** draw */\r\n    p5.draw = () => {\r\n        p5.background(200, 60, 10);\r\n        board?.update(p5.deltaTime).draw();\r\n    };\r\n\r\n    p5.mouseClicked = (e: MouseEvent) => {\r\n        if (e.button !== MOUSE_BTN.LEFT) return;\r\n        // console.log(board);\r\n\r\n        // p5.background(200, 60, 10);\r\n        // board.nextMove(board);\r\n        // board.update(1).draw();\r\n    };\r\n\r\n    /**--------------------------------- */\r\n    // functions\r\n\r\n    function resizeDisplay(canvas: P5) {\r\n        canvas.resizeCanvas(window.innerWidth, window.innerHeight);\r\n    }\r\n\r\n    function init(p5: P5) {\r\n        p5.background(200, 60, 10);\r\n\r\n        //setup board\r\n        board = new CrossBoard(p5, { currentPlayer: Gamer.PLAYER, showHelpers: options.showHelpers, onResolve });\r\n        board.currentPlayer === Gamer.PLAYER ? p5.loop() : p5.noLoop();\r\n    }\r\n\r\n    function onResolve(winner: Gamer) {\r\n        const text = winner === Gamer.PLAYER ? 'You Win!!' : 'You Loose!!';\r\n        console.log(text);\r\n        if (scoreContainer) scoreContainer.style.display = 'flex';\r\n        if (statusContainer) statusContainer.innerText = text;\r\n    }\r\n\r\n    /**--------------------------------- */\r\n    // classes\r\n};\r\n\r\nnew P5(sketch);\r\n","import P5 from 'p5';\r\nimport { Gamer } from 'src/utils/utils';\r\n\r\n// --------------------------------------------------------\r\nconst OFFSET = new P5.Vector(150, 150);\r\nconst PAWN_RADIUS = 30;\r\nconst DIMENSION = 100;\r\nconst SNAP_RADIUS = 30;\r\nconst MAX_DEPTH = 5;\r\nlet count = 0;\r\nconst ENABLE_PRUNING = true;\r\n// --------------------------------------------------------\r\n\r\ntype TCrossBoard = {\r\n    cells: TCrossBoardCell[];\r\n    pawns: Pawn[];\r\n    currentPlayer: Gamer;\r\n\r\n    state: STATE;\r\n    showHelpers: boolean;\r\n    onResolve?: (status: Gamer) => void;\r\n};\r\ntype TCrossBoardConfig = Pick<TCrossBoard, 'currentPlayer' | 'showHelpers' | 'onResolve'>;\r\n\r\ntype TCrossBoardCell = {\r\n    id: number;\r\n    pos: P5.Vector;\r\n    connectingIndices: [number, number | undefined][];\r\n    pawn: null | Pawn;\r\n};\r\n\r\ntype TCrossBoardPawn = {\r\n    id: number;\r\n    pos: P5.Vector;\r\n    owner: Gamer;\r\n    cellIndex: number;\r\n\r\n    board: CrossBoard;\r\n    state: STATE;\r\n    targetCell: number;\r\n};\r\ntype TCrossBoardPawnConfig = Pick<TCrossBoardPawn, 'id' | 'board' | 'owner' | 'cellIndex'>;\r\n\r\ntype TBestMove = {\r\n    pawnId: number;\r\n    targetCellIndex: number;\r\n    capturedPawnId?: number;\r\n    bestScore: number;\r\n} | null;\r\n\r\ntype Keys = 'showHelpers';\r\n\r\nenum STATE {\r\n    NORMAL,\r\n    ANIMATION,\r\n    DRAG,\r\n    PAUSED\r\n}\r\n\r\n// --------------------------------------------------------\r\n// --------------------------------------------------------\r\nclass CrossBoard {\r\n    p5: P5;\r\n\r\n    cells: TCrossBoardCell[];\r\n    pawns: Pawn[];\r\n    currentPlayer: Gamer;\r\n\r\n    state: STATE;\r\n    showHelpers: boolean;\r\n    onResolve?: (status: Gamer) => void;\r\n\r\n    constructor(p5: P5, _config?: Partial<TCrossBoardConfig>) {\r\n        const config: TCrossBoardConfig = { showHelpers: false, currentPlayer: Gamer.PLAYER, ..._config };\r\n        this.p5 = p5;\r\n        this.currentPlayer = config.currentPlayer;\r\n        this.pawns = buildPawns(p5, this);\r\n        this.cells = buildBoard(p5, this.pawns);\r\n\r\n        this.state = STATE.NORMAL;\r\n        this.showHelpers = config.showHelpers;\r\n        this.onResolve = config.onResolve;\r\n    }\r\n\r\n    checkGameStatus(board: CrossBoard): Gamer | undefined {\r\n        let aiPawns = 0;\r\n        let playerPawns = 0;\r\n        board.pawns.forEach((p) => (p.owner === Gamer.AI ? ++aiPawns : ++playerPawns));\r\n        let winner = aiPawns === 0 ? Gamer.PLAYER : playerPawns === 0 ? Gamer.AI : undefined;\r\n        return winner;\r\n    }\r\n\r\n    checkScore(board: CrossBoard, player: Gamer): { score: number; hasWon: boolean } {\r\n        let score = 0;\r\n        let hasWon = false;\r\n        // const hasWon = !board.pawns.some((p) => p.owner === Gamer.AI) || !board.pawns.some((p) => p.owner === Gamer.PLAYER);\r\n        for (const pawn of board.pawns) {\r\n            score += pawn.owner === player ? -1 : 1;\r\n        }\r\n        // multiply with a large number to influence the weight\r\n        if (!board.pawns.some((p) => p.owner === Gamer.AI)) {\r\n            score *= 1000;\r\n            hasWon = true;\r\n        } else if (!board.pawns.some((p) => p.owner === Gamer.PLAYER)) {\r\n            score *= -1000;\r\n            hasWon = true;\r\n        }\r\n        return { score, hasWon };\r\n    }\r\n\r\n    nextMove() {\r\n        count = 0;\r\n        const board = this;\r\n        const currentPlayer = this.currentPlayer;\r\n        const nextPlayer = currentPlayer === Gamer.AI ? Gamer.PLAYER : Gamer.AI;\r\n        let bestScore = -Infinity;\r\n        let bestMove: TBestMove = null;\r\n        let alpha = -Infinity;\r\n        let beta = Infinity;\r\n        this.p5.noLoop();\r\n\r\n        // search through the available pawns\r\n        for (const pawn of board.pawns) {\r\n            if (pawn.owner !== currentPlayer) continue;\r\n            const currentCell = board.cells[pawn.cellIndex];\r\n\r\n            // find neighbour cell\r\n            for (const connector of currentCell.connectingIndices) {\r\n                const neighbourCellIndex = connector[0];\r\n                const capturableCellIndex = connector[1];\r\n                const neighbourPawn = board.cells[neighbourCellIndex].pawn;\r\n\r\n                // check for capturable cells\r\n                if (\r\n                    capturableCellIndex !== undefined &&\r\n                    !board.cells[capturableCellIndex].pawn &&\r\n                    neighbourPawn &&\r\n                    neighbourPawn.owner !== currentPlayer\r\n                ) {\r\n                    // pre-calc\r\n                    const stashCellIndex = pawn.cellIndex;\r\n                    pawn.cellIndex = capturableCellIndex;\r\n                    board.cells[capturableCellIndex].pawn = pawn;\r\n                    board.cells[stashCellIndex].pawn = null;\r\n                    // delete captured pawn\r\n                    const capturedPawn = neighbourPawn;\r\n                    const index = board.pawns.findIndex((p) => p.id === capturedPawn.id);\r\n                    if (index > -1) {\r\n                        board.cells[neighbourCellIndex].pawn = null;\r\n                        board.pawns.splice(index, 1);\r\n                    }\r\n\r\n                    // depth\r\n                    const score = this.minimax(\r\n                        board,\r\n                        MAX_DEPTH,\r\n                        false,\r\n                        currentPlayer,\r\n                        alpha,\r\n                        beta,\r\n                        `cap// pawn(${pawn.id}) ${stashCellIndex}-${capturableCellIndex}`\r\n                    );\r\n                    // undo minimax changes\r\n                    board.pawns.splice(index, 0, capturedPawn);\r\n                    board.cells[capturedPawn.cellIndex].pawn = capturedPawn;\r\n                    pawn.cellIndex = stashCellIndex;\r\n                    board.cells[stashCellIndex].pawn = pawn;\r\n                    board.cells[neighbourCellIndex].pawn = capturedPawn;\r\n                    board.cells[capturableCellIndex].pawn = null;\r\n\r\n                    if (score > bestScore) {\r\n                        bestScore = score;\r\n                        bestMove = {\r\n                            pawnId: pawn.id,\r\n                            targetCellIndex: capturableCellIndex,\r\n                            capturedPawnId: capturedPawn.id,\r\n                            bestScore\r\n                        };\r\n                    }\r\n                }\r\n\r\n                // check for neighbour cells\r\n                else if (!neighbourPawn) {\r\n                    // pre-calc\r\n                    const stashCellIndex = pawn.cellIndex;\r\n                    pawn.cellIndex = neighbourCellIndex;\r\n                    board.cells[neighbourCellIndex].pawn = pawn;\r\n                    board.cells[stashCellIndex].pawn = null;\r\n\r\n                    // depth\r\n                    const score = this.minimax(\r\n                        board,\r\n                        MAX_DEPTH,\r\n                        false,\r\n                        currentPlayer,\r\n                        alpha,\r\n                        beta,\r\n                        `mov// pawn(${pawn.id}) ${stashCellIndex}-${neighbourCellIndex}`\r\n                    );\r\n                    // undo minimax changes\r\n                    pawn.cellIndex = stashCellIndex;\r\n                    board.cells[stashCellIndex].pawn = pawn;\r\n                    board.cells[neighbourCellIndex].pawn = null;\r\n\r\n                    if (score > bestScore) {\r\n                        bestScore = score;\r\n                        bestMove = { pawnId: pawn.id, targetCellIndex: neighbourCellIndex, bestScore };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // initiate board move\r\n        if (bestMove) {\r\n            this.movePawn(board, bestMove);\r\n\r\n            // check for a winner\r\n            const winner = board.checkGameStatus(board);\r\n\r\n            if (winner !== undefined) {\r\n                board.state = this.state = STATE.PAUSED;\r\n                board.onResolve && board.onResolve(winner);\r\n                return;\r\n            }\r\n\r\n            // toggle player if noo winner\r\n            board.currentPlayer = nextPlayer;\r\n            this.p5.loop();\r\n        }\r\n    }\r\n\r\n    minimax(\r\n        board: CrossBoard,\r\n        depth: number,\r\n        isMaximizing: boolean,\r\n        lastPlayer: Gamer,\r\n        alpha: number,\r\n        beta: number,\r\n        status: string\r\n    ): number {\r\n        ++count;\r\n        const { score, hasWon } = this.checkScore(board, lastPlayer);\r\n\r\n        const currentPlayer = lastPlayer === Gamer.AI ? Gamer.PLAYER : Gamer.AI;\r\n        // if (depth <= 0 || count > 100) return score;\r\n        // if (depth <= 0) return score;\r\n        if (depth <= 0 || hasWon) return score * (depth + 1);\r\n\r\n        if (isMaximizing) {\r\n            let bestScore = -Infinity;\r\n            // calc start\r\n            for (const pawn of board.pawns) {\r\n                if (pawn.owner !== currentPlayer) continue;\r\n                const currentCell = board.cells[pawn.cellIndex];\r\n\r\n                // find neighbour cell\r\n                for (const connector of currentCell.connectingIndices) {\r\n                    const neighbourCellIndex = connector[0];\r\n                    const capturableCellIndex = connector[1];\r\n                    const neighbourPawn = board.cells[neighbourCellIndex].pawn;\r\n\r\n                    // check for capturable cells\r\n                    if (\r\n                        capturableCellIndex !== undefined &&\r\n                        !board.cells[capturableCellIndex].pawn &&\r\n                        neighbourPawn &&\r\n                        neighbourPawn.owner !== currentPlayer\r\n                    ) {\r\n                        // pre-calc\r\n                        const stashCellIndex = pawn.cellIndex;\r\n                        pawn.cellIndex = capturableCellIndex;\r\n                        board.cells[capturableCellIndex].pawn = pawn;\r\n                        board.cells[stashCellIndex].pawn = null;\r\n                        // delete captured pawn\r\n                        const capturedPawn = neighbourPawn;\r\n                        const index = board.pawns.findIndex((p) => p.id === capturedPawn.id);\r\n                        if (index > -1) {\r\n                            board.cells[neighbourCellIndex].pawn = null;\r\n                            board.pawns.splice(index, 1);\r\n                        }\r\n\r\n                        // depth\r\n                        const score = this.minimax(\r\n                            board,\r\n                            depth - 1,\r\n                            false,\r\n                            currentPlayer,\r\n                            alpha,\r\n                            beta,\r\n                            `cap++ pawn(${pawn.id}) ${stashCellIndex}-${capturableCellIndex}`\r\n                        );\r\n                        bestScore = Math.max(score, bestScore);\r\n\r\n                        // undo minimax changes\r\n                        board.pawns.splice(index, 0, capturedPawn);\r\n                        board.cells[capturedPawn.cellIndex].pawn = capturedPawn;\r\n                        pawn.cellIndex = stashCellIndex;\r\n                        board.cells[stashCellIndex].pawn = pawn;\r\n                        board.cells[neighbourCellIndex].pawn = capturedPawn;\r\n                        board.cells[capturableCellIndex].pawn = null;\r\n\r\n                        // alpha-beta\r\n                        if (ENABLE_PRUNING) {\r\n                            alpha = Math.max(alpha, score);\r\n                            if (beta <= alpha) break;\r\n                        }\r\n                    }\r\n\r\n                    // check for neighbour cells\r\n                    else if (!neighbourPawn) {\r\n                        // pre-calc\r\n                        const stashCellIndex = pawn.cellIndex;\r\n                        pawn.cellIndex = neighbourCellIndex;\r\n                        board.cells[neighbourCellIndex].pawn = pawn;\r\n                        board.cells[stashCellIndex].pawn = null;\r\n\r\n                        // depth\r\n                        const score = this.minimax(\r\n                            board,\r\n                            depth - 1,\r\n                            false,\r\n                            currentPlayer,\r\n                            alpha,\r\n                            beta,\r\n                            `mov++ pawn(${pawn.id}) ${stashCellIndex}-${neighbourCellIndex}`\r\n                        );\r\n                        bestScore = Math.max(score, bestScore);\r\n\r\n                        // undo minimax changes\r\n                        pawn.cellIndex = stashCellIndex;\r\n                        board.cells[stashCellIndex].pawn = pawn;\r\n                        board.cells[neighbourCellIndex].pawn = null;\r\n\r\n                        // alpha-beta\r\n                        if (ENABLE_PRUNING) {\r\n                            alpha = Math.max(alpha, score);\r\n                            if (beta <= alpha) break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // calc end\r\n            return bestScore;\r\n        } else {\r\n            let bestScore = Infinity;\r\n            // calc start\r\n            for (const pawn of board.pawns) {\r\n                if (pawn.owner !== currentPlayer) continue;\r\n                const currentCell = board.cells[pawn.cellIndex];\r\n\r\n                // find neighbour cell\r\n                for (const connector of currentCell.connectingIndices) {\r\n                    const neighbourCellIndex = connector[0];\r\n                    const capturableCellIndex = connector[1];\r\n                    const neighbourPawn = board.cells[neighbourCellIndex].pawn;\r\n\r\n                    // check for capturable cells\r\n                    if (\r\n                        capturableCellIndex !== undefined &&\r\n                        !board.cells[capturableCellIndex].pawn &&\r\n                        neighbourPawn &&\r\n                        neighbourPawn.owner !== currentPlayer\r\n                    ) {\r\n                        // pre-calc\r\n                        const stashCellIndex = pawn.cellIndex;\r\n                        pawn.cellIndex = capturableCellIndex;\r\n                        board.cells[capturableCellIndex].pawn = pawn;\r\n                        board.cells[stashCellIndex].pawn = null;\r\n                        // delete captured pawn\r\n                        const capturedPawn = neighbourPawn;\r\n                        const index = board.pawns.findIndex((p) => p.id === capturedPawn.id);\r\n                        if (index > -1) {\r\n                            board.cells[neighbourCellIndex].pawn = null;\r\n                            board.pawns.splice(index, 1);\r\n                        }\r\n\r\n                        // depth\r\n                        const score = this.minimax(\r\n                            board,\r\n                            depth - 1,\r\n                            true,\r\n                            currentPlayer,\r\n                            alpha,\r\n                            beta,\r\n                            `cap-- pawn(${pawn.id}) ${stashCellIndex}-${capturableCellIndex}`\r\n                        );\r\n                        bestScore = Math.min(score, bestScore);\r\n\r\n                        // undo minimax changes\r\n                        board.pawns.splice(index, 0, capturedPawn);\r\n                        board.cells[capturedPawn.cellIndex].pawn = capturedPawn;\r\n                        pawn.cellIndex = stashCellIndex;\r\n                        board.cells[stashCellIndex].pawn = pawn;\r\n                        board.cells[neighbourCellIndex].pawn = capturedPawn;\r\n                        board.cells[capturableCellIndex].pawn = null;\r\n\r\n                        // alpha-beta\r\n                        if (ENABLE_PRUNING) {\r\n                            beta = Math.min(beta, score);\r\n                            if (beta <= alpha) break;\r\n                        }\r\n                    }\r\n\r\n                    // check for neighbour cells\r\n                    else if (!neighbourPawn) {\r\n                        // pre-calc\r\n                        const stashCellIndex = pawn.cellIndex;\r\n                        pawn.cellIndex = neighbourCellIndex;\r\n                        board.cells[neighbourCellIndex].pawn = pawn;\r\n                        board.cells[stashCellIndex].pawn = null;\r\n\r\n                        // depth\r\n                        const score = this.minimax(\r\n                            board,\r\n                            depth - 1,\r\n                            true,\r\n                            currentPlayer,\r\n                            alpha,\r\n                            beta,\r\n                            `mov-- pawn(${pawn.id}) ${stashCellIndex}-${neighbourCellIndex}`\r\n                        );\r\n                        bestScore = Math.min(score, bestScore);\r\n\r\n                        // undo minimax changes\r\n                        pawn.cellIndex = stashCellIndex;\r\n                        board.cells[stashCellIndex].pawn = pawn;\r\n                        board.cells[neighbourCellIndex].pawn = null;\r\n\r\n                        // alpha-beta\r\n                        if (ENABLE_PRUNING) {\r\n                            beta = Math.min(beta, score);\r\n                            if (beta <= alpha) break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // calc end\r\n            return bestScore;\r\n        }\r\n    }\r\n\r\n    movePawn(board: CrossBoard, bestMove: TBestMove): CrossBoard {\r\n        if (!bestMove) return board;\r\n        const { pawnId, targetCellIndex, capturedPawnId } = bestMove;\r\n        const pawn = board.pawns.find((p) => p.id === pawnId);\r\n        if (pawn !== undefined) {\r\n            const tempCell = pawn.cellIndex;\r\n            pawn.cellIndex = targetCellIndex;\r\n            board.cells[targetCellIndex].pawn = pawn;\r\n            board.cells[tempCell].pawn = null;\r\n\r\n            if (capturedPawnId !== undefined) {\r\n                const capturedPawn = board.pawns.find((p) => p.id === capturedPawnId);\r\n                if (!capturedPawn) return board;\r\n                const index = board.pawns.findIndex((p) => p.id === capturedPawn?.id);\r\n                if (index > -1) {\r\n                    board.cells[capturedPawn.cellIndex].pawn = null;\r\n                    board.pawns.splice(index, 1);\r\n                }\r\n            }\r\n        }\r\n        return board;\r\n    }\r\n    update(deltaTime: number): this {\r\n        // board:update()\r\n        // update pawns\r\n        for (let i = 0; i < this.pawns.length; i++) {\r\n            const pawn = this.pawns[i];\r\n            const cell = this.cells[pawn.cellIndex];\r\n            // pawn.update(this.p5.deltaTime, OFFSET.x + cell.pos.x * DIMENSION, OFFSET.y + cell.pos.y * DIMENSION);\r\n            pawn.update(deltaTime, OFFSET.x, OFFSET.y);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    draw() {\r\n        // bord:draw()\r\n        this.p5.cursor(this.p5.ARROW);\r\n\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            const { x: x1, y: y1 } = this.cells[i].pos;\r\n            const posX = OFFSET.x + x1 * DIMENSION;\r\n            const posY = OFFSET.y + y1 * DIMENSION;\r\n            const currentCellPos = this.p5.createVector(posX, posY);\r\n\r\n            // draw lines to neighbours\r\n            this.cells[i].connectingIndices.forEach((neighbour) => {\r\n                const index = neighbour[0];\r\n                const { x: x2, y: y2 } = this.cells[index].pos;\r\n                this.p5.strokeWeight(2);\r\n                this.p5.stroke(255, 0.1);\r\n                this.p5.line(posX, posY, OFFSET.x + x2 * DIMENSION, OFFSET.y + y2 * DIMENSION);\r\n            });\r\n\r\n            // draw helpers\r\n            if (this.showHelpers) {\r\n                // points texts\r\n                this.p5.stroke(255);\r\n                this.p5.strokeWeight(1);\r\n                this.p5.noFill();\r\n                this.p5.text(\r\n                    `${this.cells[i].id}  ${this.cells[i].pawn !== null ? this.cells[i].pawn?.id : ''}`,\r\n                    posX + 25,\r\n                    posY - 5\r\n                );\r\n            }\r\n\r\n            // draw hover point\r\n            if ((this.state === STATE.NORMAL || this.state === STATE.DRAG) && this.cells[i].pawn?.owner !== Gamer.AI) {\r\n                const distance = this.p5.createVector(this.p5.mouseX, this.p5.mouseY).sub(currentCellPos).mag();\r\n                if (distance < PAWN_RADIUS) {\r\n                    this.p5.cursor(this.p5.HAND);\r\n                    this.p5.noStroke();\r\n                    this.p5.fill(255);\r\n                    this.p5.circle(\r\n                        currentCellPos.x,\r\n                        currentCellPos.y,\r\n                        this.p5.constrain(PAWN_RADIUS - distance, 0, PAWN_RADIUS * 0.5)\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        // draw cells\r\n        for (const pawn of this.pawns) {\r\n            pawn.draw();\r\n        }\r\n    }\r\n\r\n    setValues(key: Keys, value: boolean) {\r\n        switch (key) {\r\n            case 'showHelpers':\r\n                this.showHelpers = value;\r\n                break;\r\n            default:\r\n                throw 'Unsupported key passed to setValues()';\r\n        }\r\n    }\r\n\r\n    resetGame(_config?: Partial<TCrossBoardConfig>) {\r\n        const config: TCrossBoardConfig = { showHelpers: false, currentPlayer: Gamer.PLAYER, ..._config };\r\n        this.currentPlayer = config.currentPlayer;\r\n        this.pawns = buildPawns(this.p5, this);\r\n        this.cells = buildBoard(this.p5, this.pawns);\r\n\r\n        this.state = STATE.NORMAL;\r\n        this.showHelpers = config.showHelpers;\r\n        this.onResolve = config.onResolve;\r\n    }\r\n}\r\n\r\n// --------------------------------------------------------\r\n// --------------------------------------------------------\r\nclass Pawn {\r\n    p5: P5;\r\n    id: number;\r\n    pos: P5.Vector;\r\n    owner: Gamer;\r\n    cellIndex: number;\r\n\r\n    board: CrossBoard;\r\n    state: STATE;\r\n    targetCell: number;\r\n\r\n    constructor(p5: P5, config: TCrossBoardPawnConfig) {\r\n        this.p5 = p5;\r\n        this.id = config.id;\r\n        this.board = config.board;\r\n        this.owner = config.owner;\r\n        this.cellIndex = config.cellIndex;\r\n        this.pos = p5.createVector(0, 0);\r\n        this.state = STATE.NORMAL;\r\n    }\r\n    update(deltaTime: number, offsetX: number, offsetY: number): this {\r\n        // pawn:update()\r\n        const board = this.board;\r\n        const cells = this.board.cells;\r\n        const parentPos = this.p5.createVector(\r\n            offsetX + cells[this.cellIndex].pos.x * DIMENSION,\r\n            offsetY + cells[this.cellIndex].pos.y * DIMENSION\r\n        );\r\n        const mousePos = this.p5.createVector(this.p5.mouseX, this.p5.mouseY);\r\n\r\n        // update Cells at rest\r\n        if (this.state === STATE.NORMAL && board.state === STATE.NORMAL && !this.p5.mouseIsPressed) {\r\n            this.pos.set(parentPos.x, parentPos.y);\r\n\r\n            return this;\r\n        }\r\n\r\n        // initiate dragging\r\n        if (\r\n            this.owner === Gamer.PLAYER &&\r\n            this.p5.mouseIsPressed &&\r\n            board.state === STATE.NORMAL &&\r\n            this.state === STATE.NORMAL\r\n        ) {\r\n            const distance = parentPos.copy().sub(mousePos).mag();\r\n            if (distance < SNAP_RADIUS) {\r\n                board.state = this.state = STATE.DRAG;\r\n                return this;\r\n            }\r\n        }\r\n\r\n        // continue dragging\r\n        if (this.owner === Gamer.PLAYER && this.state === STATE.DRAG && this.p5.mouseIsPressed) {\r\n            this.pos.set(mousePos.x, mousePos.y);\r\n        }\r\n\r\n        // finish drag state when mouseup\r\n        if (this.owner === Gamer.PLAYER && this.state === STATE.DRAG && !this.p5.mouseIsPressed) {\r\n            board.state = this.state = STATE.ANIMATION;\r\n\r\n            // calculate the permissible cells\r\n            const length = board.cells.length;\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                if (this.cellIndex === i || cells[i].pawn) continue;\r\n\r\n                const currentCell = cells[i];\r\n\r\n                const pos = this.p5.createVector(\r\n                    offsetX + currentCell.pos.x * DIMENSION,\r\n                    offsetY + currentCell.pos.y * DIMENSION\r\n                );\r\n                const distance = pos.copy().sub(this.pos).mag();\r\n                if (distance < SNAP_RADIUS) {\r\n                    const { isLegal } = this.getLegalMove(board, this.cellIndex, i);\r\n\r\n                    if (!isLegal) continue;\r\n                    // set the new target cell to move\r\n                    this.targetCell = i;\r\n                    return this;\r\n                }\r\n            }\r\n\r\n            // no snappable points, return to home\r\n            this.targetCell = this.cellIndex;\r\n\r\n            return this;\r\n        }\r\n\r\n        // travel to position\r\n        if (this.state === STATE.ANIMATION) {\r\n            const targetPos = this.p5.createVector(\r\n                offsetX + cells[this.targetCell].pos.x * DIMENSION,\r\n                offsetY + cells[this.targetCell].pos.y * DIMENSION\r\n            );\r\n            const distance = targetPos.copy().sub(this.pos).mag();\r\n\r\n            // if near a cell, snap to it\r\n            if (distance < SNAP_RADIUS) {\r\n                board.state = this.state = STATE.NORMAL;\r\n                this.pos.set(targetPos.x, targetPos.y);\r\n\r\n                // commit to the move\r\n                if (this.targetCell !== this.cellIndex) {\r\n                    const { capturedPawnId, isLegal } = this.getLegalMove(board, this.cellIndex, this.targetCell);\r\n\r\n                    if (!isLegal) return this;\r\n\r\n                    const bestMove: TBestMove = {\r\n                        pawnId: this.id,\r\n                        targetCellIndex: this.targetCell,\r\n                        capturedPawnId,\r\n                        bestScore: 0\r\n                    };\r\n                    board.movePawn(board, bestMove);\r\n\r\n                    // check for a winner\r\n                    if (board.currentPlayer === Gamer.PLAYER) {\r\n                        const winner = board.checkGameStatus(board);\r\n                        if (winner !== undefined) {\r\n                            board.state = this.state = STATE.PAUSED;\r\n                            board.onResolve && board.onResolve(winner);\r\n                            return this;\r\n                        }\r\n\r\n                        // if there is no winner\r\n                        board.currentPlayer = Gamer.AI;\r\n                        board.nextMove();\r\n                    }\r\n                }\r\n                return this;\r\n            }\r\n\r\n            // if not near any cells, move to target\r\n            this.pos.add(targetPos).div(2);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    draw() {\r\n        // pawn:draw()\r\n        const { mouseX, mouseY } = this.p5;\r\n        // pawn style\r\n        this.p5.noStroke();\r\n        this.owner === Gamer.AI ? this.p5.fill(10, 80, 70) : this.p5.fill(200, 80, 70);\r\n        this.p5.ellipseMode(this.p5.CENTER);\r\n        this.p5.circle(this.pos.x, this.pos.y, PAWN_RADIUS);\r\n\r\n        // draw curson\r\n        if (this.owner === Gamer.PLAYER && this.p5.createVector(mouseX, mouseY).dist(this.pos) < PAWN_RADIUS) {\r\n            this.p5.cursor(this.p5.HAND);\r\n        }\r\n\r\n        if (this.board.showHelpers) {\r\n            // points texts\r\n            this.p5.stroke(255);\r\n            this.p5.strokeWeight(1);\r\n            this.p5.noFill();\r\n            this.p5.textAlign(this.p5.CENTER, this.p5.CENTER);\r\n            this.p5.text(`${this.id} (${this.cellIndex})`, this.pos.x, this.pos.y);\r\n        }\r\n    }\r\n\r\n    getLegalMove(\r\n        board: TCrossBoard,\r\n        currentCellIndex: number,\r\n        targetCellIndex: number\r\n    ): { isLegal: boolean; capturedPawnId: number | undefined } {\r\n        let isLegal = false;\r\n        let capturedPawnId;\r\n        const cell = board.cells[currentCellIndex];\r\n\r\n        for (let i = 0; i < cell.connectingIndices.length; i++) {\r\n            const connector = cell.connectingIndices[i];\r\n            if (connector[0] === targetCellIndex) isLegal = true;\r\n            if (\r\n                connector[1] === targetCellIndex &&\r\n                board.cells[connector[0]].pawn?.owner !== this.owner &&\r\n                board.cells[connector[0]].pawn?.owner !== undefined\r\n            ) {\r\n                const capturedPawn = board.pawns.find((p) => p.cellIndex === connector[0]);\r\n                capturedPawnId = capturedPawn?.id;\r\n                isLegal = true;\r\n            }\r\n        }\r\n\r\n        return { isLegal, capturedPawnId };\r\n    }\r\n}\r\n\r\n// --------------------------------------------------------\r\n// --------------------------------------------------------\r\nfunction buildPawns(p5: P5, board: CrossBoard) {\r\n    const pawns: Pawn[] = [\r\n        new Pawn(p5, { id: 0, board, owner: Gamer.AI, cellIndex: 0 }),\r\n        new Pawn(p5, { id: 1, board, owner: Gamer.AI, cellIndex: 1 }),\r\n        new Pawn(p5, { id: 2, board, owner: Gamer.AI, cellIndex: 2 }),\r\n        new Pawn(p5, { id: 3, board, owner: Gamer.AI, cellIndex: 3 }),\r\n        new Pawn(p5, { id: 4, board, owner: Gamer.AI, cellIndex: 4 }),\r\n        // new Pawn(p5, { id: 4, board, owner: Gamer.AI, cellIndex: 6 }),\r\n\r\n        new Pawn(p5, { id: 5, board, owner: Gamer.PLAYER, cellIndex: 8 }),\r\n        new Pawn(p5, { id: 6, board, owner: Gamer.PLAYER, cellIndex: 9 }),\r\n        new Pawn(p5, { id: 7, board, owner: Gamer.PLAYER, cellIndex: 10 }),\r\n        new Pawn(p5, { id: 8, board, owner: Gamer.PLAYER, cellIndex: 11 }),\r\n        new Pawn(p5, { id: 9, board, owner: Gamer.PLAYER, cellIndex: 12 })\r\n    ];\r\n\r\n    return pawns;\r\n}\r\n\r\nfunction buildBoard(p5: P5, pawns: Pawn[]) {\r\n    // build points\r\n    const points: TCrossBoardCell[] = [\r\n        {\r\n            id: 0,\r\n            pos: p5.createVector(0, 0),\r\n            connectingIndices: [\r\n                [1, 2],\r\n                [3, 6],\r\n                [5, 10]\r\n            ],\r\n            pawn: pawns[0]\r\n        },\r\n        {\r\n            id: 1,\r\n            pos: p5.createVector(2, 0),\r\n            connectingIndices: [\r\n                [0, undefined],\r\n                [2, undefined],\r\n                [3, 5],\r\n                [4, 7],\r\n                [6, 11]\r\n            ],\r\n            pawn: pawns[1]\r\n        },\r\n        {\r\n            id: 2,\r\n            pos: p5.createVector(4, 0),\r\n            connectingIndices: [\r\n                [1, 0],\r\n                [4, 6],\r\n                [7, 12]\r\n            ],\r\n            pawn: pawns[2]\r\n        },\r\n\r\n        {\r\n            id: 3,\r\n            pos: p5.createVector(1, 1),\r\n            connectingIndices: [\r\n                [0, undefined],\r\n                [1, undefined],\r\n                [6, 9],\r\n                [5, undefined]\r\n            ],\r\n            pawn: pawns[3]\r\n        },\r\n        {\r\n            id: 4,\r\n            pos: p5.createVector(3, 1),\r\n            connectingIndices: [\r\n                [1, undefined],\r\n                [2, undefined],\r\n                [7, undefined],\r\n                [6, 8]\r\n            ],\r\n            pawn: pawns[4]\r\n            // pawn: null\r\n        },\r\n\r\n        {\r\n            id: 5,\r\n            pos: p5.createVector(0, 2),\r\n            connectingIndices: [\r\n                [0, undefined],\r\n                [3, 1],\r\n                [6, 7],\r\n                [8, 11],\r\n                [10, undefined]\r\n            ],\r\n            pawn: null\r\n        },\r\n        {\r\n            id: 6,\r\n            pos: p5.createVector(2, 2),\r\n            connectingIndices: [\r\n                [3, 0],\r\n                [1, undefined],\r\n                [4, 2],\r\n                [7, undefined],\r\n                [9, 12],\r\n                [11, undefined],\r\n                [8, 10],\r\n                [5, undefined]\r\n            ],\r\n            pawn: null\r\n            // pawn: pawns[4]\r\n        },\r\n        {\r\n            id: 7,\r\n            pos: p5.createVector(4, 2),\r\n            connectingIndices: [\r\n                [4, 1],\r\n                [2, undefined],\r\n                [12, undefined],\r\n                [9, 11],\r\n                [6, 5]\r\n            ],\r\n            pawn: null\r\n        },\r\n\r\n        {\r\n            id: 8,\r\n            pos: p5.createVector(1, 3),\r\n            connectingIndices: [\r\n                [5, undefined],\r\n                [6, 4],\r\n                [11, undefined],\r\n                [10, undefined]\r\n            ],\r\n            pawn: pawns[5]\r\n        },\r\n        {\r\n            id: 9,\r\n            pos: p5.createVector(3, 3),\r\n            connectingIndices: [\r\n                [6, 3],\r\n                [7, undefined],\r\n                [12, undefined],\r\n                [11, undefined]\r\n            ],\r\n            pawn: pawns[6]\r\n        },\r\n\r\n        {\r\n            id: 10,\r\n            pos: p5.createVector(0, 4),\r\n            connectingIndices: [\r\n                [5, 0],\r\n                [8, 6],\r\n                [11, 12]\r\n            ],\r\n            pawn: pawns[7]\r\n        },\r\n        {\r\n            id: 11,\r\n            pos: p5.createVector(2, 4),\r\n            connectingIndices: [\r\n                [8, 5],\r\n                [6, 1],\r\n                [9, 7],\r\n                [12, undefined],\r\n                [10, undefined]\r\n            ],\r\n            pawn: pawns[8]\r\n        },\r\n        {\r\n            id: 12,\r\n            pos: p5.createVector(4, 4),\r\n            connectingIndices: [\r\n                [9, 6],\r\n                [7, 2],\r\n                [11, 10]\r\n            ],\r\n            pawn: pawns[9]\r\n        }\r\n    ];\r\n\r\n    return points;\r\n}\r\n\r\n// --------------------------------------------------------\r\n// --------------------------------------------------------\r\nexport default CrossBoard;\r\n"],"names":["$0af410a66d517047$var$board","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","STATE","$dc260c8a25c170be$var$STATE","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$28770b279d7ab5b1$export$bfd2dc5313efa3a3","$28770b279d7ab5b1$export$4008efb11b076cd5","MOUSE_BTN","Gamer","$28770b279d7ab5b1$export$73820bb3da69f923","$28770b279d7ab5b1$export$1ea8cd15d9ca5dee","r","top","right","bottom","left","$e93rA","$7Pz0b","$fK5g3","$dc260c8a25c170be$var$OFFSET","Vector","$dc260c8a25c170be$var$count","$dc260c8a25c170be$var$Pawn","constructor","p5","config","board","owner","cellIndex","pos","createVector","state","update","deltaTime","offsetX","offsetY","cells","parentPos","x","y","mousePos","mouseX","mouseY","mouseIsPressed","PLAYER","distance","copy","sub","mag","length","i","pawn","currentCell","isLegal","getLegalMove","targetCell","targetPos","capturedPawnId","bestMove","pawnId","targetCellIndex","bestScore","movePawn","currentPlayer","winner","checkGameStatus","undefined","onResolve","AI","nextMove","add","div","draw","noStroke","fill","ellipseMode","CENTER","circle","dist","cursor","HAND","showHelpers","stroke","strokeWeight","noFill","textAlign","text","currentCellIndex","cell","connectingIndices","connector","capturedPawn","pawns","find","p","$dc260c8a25c170be$var$buildPawns","$dc260c8a25c170be$var$buildBoard","$dc260c8a25c170be$export$2e2bcd8739ae039","_config","aiPawns","playerPawns","forEach","checkScore","player","score","hasWon","some","nextPlayer","Infinity","alpha","beta","noLoop","neighbourCellIndex","capturableCellIndex","neighbourPawn","stashCellIndex","index","findIndex","splice","minimax","loop","depth","isMaximizing","lastPlayer","status","Math","max","min","tempCell","ARROW","x1","y1","posX","posY","currentCellPos","neighbour","x2","y2","line","constrain","$dc260c8a25c170be$var$PAWN_RADIUS","setValues","key","value","resetGame","$0af410a66d517047$var$scoreContainer","document","getElementById","$0af410a66d517047$var$statusContainer","options","size","gui","GUI","autoPlace","console","log","style","display","innerText","domElement","appendChild","onChange","val","setup","canvas","createCanvas","window","innerWidth","innerHeight","parent","background","pixelDensity","colorMode","HSB","addEventListener","resizeDisplay","resizeCanvas","event","preventDefault","mouseClicked","button","LEFT"],"version":3,"file":"board-game.07ec6702.js.map"}